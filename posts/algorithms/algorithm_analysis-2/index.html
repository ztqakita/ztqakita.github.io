<!doctype html><html><head><title>Dynamic Programming</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/layouts/main.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/navigators/navbar.css><link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png><link rel=stylesheet href=/css/style.css><meta name=description content="Dynamic Programming"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css><link rel=stylesheet href=/css/layouts/single.css><link rel=stylesheet href=/css/navigators/sidebar.css></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png>ztqakita's Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png class=d-none id=main-logo>
<img src=/images/inverted-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png class=d-none id=inverted-logo></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=https://ztqakita.github.io/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><a href=/posts/introduction/>Introduction</a></li><li><i class="fas fa-minus-circle"></i><a class=active href=/posts/algorithms/>Algorithms</a><ul class=active><li><a href=/posts/algorithms/algorithm_analysis-1/>Complexity & Divide and Conquer</a></li><li><a class=active href=/posts/algorithms/algorithm_analysis-2/>Dynamic Programming</a></li><li><a href=/posts/algorithms/algorithm_analysis-3/>Greedy & Back-track & Branch and Bound</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/compiler/>Compiler</a><ul><li><a href=/posts/compiler/compilers_1/>Lexcial Analysis & Parsing</a></li><li><a href=/posts/compiler/compilers_3/>Semantic Analysis & Runtime Environment</a></li><li><a href=/posts/compiler/compilers_2/>Syntax-directed Translation</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/neural-computation/>Computational Neuroscience</a><ul><li><a href=/posts/neural-computation/1-ionic_currents/>Ionic Currents</a></li><li><a href=/posts/neural-computation/basic-neuro-knowledge/>Neuroscience Basic Knowledge</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/database-system/>Database System</a><ul><li><a href=/posts/database-system/database_system_1/>Database System Lecture Note 1</a></li><li><a href=/posts/database-system/database_system_2/>Database System Lecture Note 2</a></li><li><a href=/posts/database-system/database_system_3/>Database System Lecture Note 3</a></li><li><a href=/posts/database-system/database_system_4/>Database System Lecture Note 4</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/deep-learning/>DL</a><ul><li><a href=/posts/deep-learning/cnn/>Convolutional Neural Network</a></li><li><a href=/posts/deep-learning/introduction-to-deep-learning/>Introduction to Deep Learning</a></li><li><a href=/posts/deep-learning/optimizer-for-dl/>Optimization for Deep Learning</a></li><li><a href=/posts/deep-learning/rnn/>Recursive Neural Network</a></li><li><a href=/posts/deep-learning/self-attention/>Self-attention</a></li><li><a href=/posts/deep-learning/transformer/>Transformer</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/life-learning/>Life Learning</a><ul><li><a href=/posts/life-learning/architectures_of_neuronal_circuits/>Architectures of neuronal circuits</a></li><li><a href=/posts/life-learning/how_to_model/>how to model</a></li><li><a href=/posts/life-learning/lecture_james_mcclleland/>Lecture James McClleland</a></li><li><a href=/posts/life-learning/lecture_yao_xin/>Lecture Yao Xin</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/machine-learning/>ML</a><ul><li><a href=/posts/machine-learning/basic-concepts/>Basic Concepts</a></li><li><a href=/posts/machine-learning/classification/>Classification</a></li><li><a href=/posts/machine-learning/decision-tree/>Decision Tree</a></li><li><a href=/posts/machine-learning/knn/>KNN</a></li><li><a href=/posts/machine-learning/perceptron/>Perceptron</a></li><li><a href=/posts/machine-learning/som/>SOM</a></li><li><a href=/posts/machine-learning/support-vector/>Support Vector Machines</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/operating-system/>Operating System</a><ul><li><a href=/posts/operating-system/operating_system_concepts_3/>CPU Scheduling</a></li><li><a href=/posts/operating-system/operating_system_concepts_6/>File System</a></li><li><a href=/posts/operating-system/operating_system_concepts_1/>Introduction & OS Structure</a></li><li><a href=/posts/operating-system/operating_system_concepts_7/>Mass-Storage Structure & I/O System</a></li><li><a href=/posts/operating-system/operating_system_concepts_5/>Memory Management</a></li><li><a href=/posts/operating-system/operating_system_concepts_2/>Process & Threads</a></li><li><a href=/posts/operating-system/operating_system_concepts_4/>Process Synchronization</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/paper-reading/>Paper Reading</a><ul><li><a href=/posts/paper-reading/continuous_attractor_nn/>Continuous-attractor Neural Network</a></li><li><a href=/posts/paper-reading/few-shot_class_incremental_learning/>Few-Shot Class-Incremental Learning</a></li><li><a href=/posts/paper-reading/integrated_understanding_system/>Integrated understanding system</a></li><li><a href=/posts/paper-reading/push-pull_feedback/>Push-pull feedback</a></li><li><a href=/posts/paper-reading/reservoir_decision_making/>reservoir decision making network</a></li><li><a href=/posts/paper-reading/task_representation_cognitive_tasks/>Task representations in neural networks</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(https://ztqakita.github.io/images/default-hero.jpg)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/images/author/ztq.png><h5 class=author-name>Brandon Zhang</h5><p>October 5, 2020</p></div><div class=title><h1>Dynamic Programming</h1></div><div class=post-content id=post-content><h1 id=chapter-3-dynamic-programming>Chapter 3 Dynamic Programming</h1><h2 id=i-基本思想>I. 基本思想</h2><ol><li>聪明的遍历方法<ul><li>为全遍历，不同于贪心算法的单一路径</li></ul></li><li>关键：==自底向上==</li><li>寻找最优子结构：
==该问题的最优解包含着其子问题的最优解==
验证方法：反证法</li><li>建立递推关系</li></ol><h2 id=ii-矩阵连乘问题>II. 矩阵连乘问题</h2><blockquote><p>最优解 == 以最少的数乘次数计算出矩阵连乘的乘积</p></blockquote><ol><li>引子想法：改进分治法
原本的分治法：
<img src=/images/posts/algo/11.JPG alt>
通过递归树，可以发现在递归中经常会重复计算：
<img src=/images/posts/algo/12.JPG alt>
思路是将重复计算的部分存储进二维数组之中，这种方法是基于分治法的改进方法</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>LookupChain</span>(<span style=color:#66d9ef>int</span> i<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>int</span> j)
{
  <span style=color:#66d9ef>if</span> (m[i][j] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) 
    <span style=color:#66d9ef>return</span> m[i][j];
  <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> j)
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> LookupChain(i<span style=color:#960050;background-color:#1e0010>，</span>i) <span style=color:#f92672>+</span> LookupChain(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>，</span>j) <span style=color:#f92672>+</span> p[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>p[i]<span style=color:#f92672>*</span>p[j];
  s[i][j] <span style=color:#f92672>=</span> i;
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;</span> j; k<span style=color:#f92672>++</span>) {
    <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> LookupChain(i<span style=color:#960050;background-color:#1e0010>，</span>k) <span style=color:#f92672>+</span> LookupChain(k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>，</span>j) <span style=color:#f92672>+</span> p[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>p[k]<span style=color:#f92672>*</span>p[j];
    <span style=color:#66d9ef>if</span> (t <span style=color:#f92672>&lt;</span> u) { 
      u <span style=color:#f92672>=</span> t; 
      s[i][j] <span style=color:#f92672>=</span> k;
    }
  }
  m[i][j] <span style=color:#f92672>=</span> u;
  <span style=color:#66d9ef>return</span> u;
}
</code></pre></div><ol start=2><li>动态规划法
动态规划先从最小的子问题开始计算，==自底向上==进行合并运算。这种方法不需要递归，而且也可以避免重复计算。
(1) <strong>分析最优子结构</strong>
原问题的最优解可以由子问题的最优解解决，对于动态规划问题，首先需要证明该问题==满足最优子结构性质==(利用反证法)</li></ol><blockquote><p>矩阵连乘问题符合最优子结构的证明：
假设$A[i:j]=A[i:k]+A[k+1:j]$是最小的计算量，且有$A[i:m]+A[m+1:j] &lt; A[i:k]+A[k+1:j]$，则可以发现原$A[i:j] &lt; A[i:m]+A[m+1:j]$，此时不满足假设条件，矛盾！</p></blockquote><p>(2)<strong>建立递归关系</strong>
<img src=/images/posts/algo/13.JPG alt>
<img src=/images/posts/algo/14.JPG alt></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>MatrixChain</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>int</span> n<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>m<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>s)
{
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) 
    m[i][i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> r <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; r <span style=color:#f92672>&lt;=</span> n; r<span style=color:#f92672>++</span>)  <span style=color:#75715e>// r代表了对角线，如图a 
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n <span style=color:#f92672>-</span> r <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; i<span style=color:#f92672>++</span>) 
    { <span style=color:#75715e>//代表了对每条对角线的数值
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> r <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
      m[i][j] <span style=color:#f92672>=</span> m[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> p[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>p[i]<span style=color:#f92672>*</span>p[j];
      s[i][j] <span style=color:#f92672>=</span> i;
      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;</span> j; k<span style=color:#f92672>++</span>) 
      {
          <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> m[i][k] <span style=color:#f92672>+</span> m[k<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>+</span> p[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>p[k]<span style=color:#f92672>*</span>p[j];
          <span style=color:#66d9ef>if</span> (t <span style=color:#f92672>&lt;</span> m[i][j]) 
          { 
            m[i][j] <span style=color:#f92672>=</span> t;
            s[i][j] <span style=color:#f92672>=</span> k;
          }
      }
    }
}
</code></pre></div><p>接下来需要从S[i][j]矩阵中得到加括号的方案：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>trace</span>(<span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, <span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>s)
{
    <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>==</span> j)
      <span style=color:#66d9ef>return</span>;
    trace(i, s[i][j], s);
    trace(s[i][j]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, j, s);
}
</code></pre></div><h2 id=iii-最长公共子序列>III. 最长公共子序列</h2><ol><li><p><strong>问题描述：</strong>
给定两个序列：X={ x1, x2, …..,xm}，Y={ y1, y2, ……,yn}
找出X和Y的一个最长公共子序列。</p></li><li><p><strong>划分最优子结构：</strong>
<strong>利用从后向前考虑的突破口</strong>
<img src=/images/posts/algo/15.JPG alt></p></li><li><p><strong>建立递归结构</strong>
用c[i][j]记录序列和的最长公共子序列的长度
<img src=/images/posts/algo/16.JPG alt></p></li><li><p><strong>代码</strong></p></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>LCSLength</span>(<span style=color:#66d9ef>int</span> m<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>int</span> n<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>x<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>y<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>c<span style=color:#960050;background-color:#1e0010>，</span><span style=color:#66d9ef>int</span> <span style=color:#f92672>**</span>b)
{  
    <span style=color:#66d9ef>int</span> i<span style=color:#960050;background-color:#1e0010>，</span>j;
    c[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> m; i<span style=color:#f92672>++</span>) c[i][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) c[<span style=color:#ae81ff>0</span>][i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> m; i<span style=color:#f92672>++</span>)
      <span style=color:#66d9ef>for</span> (j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j<span style=color:#f92672>++</span>) {
          <span style=color:#66d9ef>if</span> (x[i]<span style=color:#f92672>==</span>y[j]) { 
              c[i][j]<span style=color:#f92672>=</span>c[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>; 
              b[i][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;
          }
          <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (c[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j]<span style=color:#f92672>&gt;=</span>c[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) 
          <span style=color:#75715e>//此处有问题
</span><span style=color:#75715e></span>          {
              c[i][j]<span style=color:#f92672>=</span>c[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][j]; 
              b[i][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>;
          }
          <span style=color:#66d9ef>else</span> { 
            c[i][j]<span style=color:#f92672>=</span>c[i][j<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]; 
            b[i][j]<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>; 
          }
      }
}
</code></pre></div><ol start=5><li>扩展：求最长上升子序列</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>LIS</span>(<span style=color:#66d9ef>int</span> a[], <span style=color:#66d9ef>int</span> b[], <span style=color:#66d9ef>int</span> n)
{
    <span style=color:#66d9ef>int</span> c[n][n], d[n][n];
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i <span style=color:#f92672>++</span>)
      b[i] <span style=color:#f92672>=</span> a[i];
    quickSort(a, <span style=color:#ae81ff>1</span>, n);
    LCSLength(n, a, b, c, d);
}
</code></pre></div><ol start=6><li>扩展：利用最长公共子序列求解回文词的构造问题
解决思路：首先将给定的字符串 X 翻转得到<strong>它的逆串 Y</strong>，然后求 X 与 Y 的最长公共子序列，那么 X 的字符个数 n 减去最长公共子序列的长度即为将 X 变成回文串时最少需要添加的字符个数。</li></ol><h2 id=iv-最大子段和>IV. 最大子段和</h2><p>代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>maxSum</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>a)
{
    <span style=color:#66d9ef>int</span> sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>)
    {
      <span style=color:#66d9ef>if</span>(b <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
        b <span style=color:#f92672>+=</span> a[i];
      <span style=color:#66d9ef>else</span>
        b <span style=color:#f92672>=</span> a[i];
      <span style=color:#66d9ef>if</span>(b <span style=color:#f92672>&gt;</span> sum)
        sum <span style=color:#f92672>=</span> b;
    }
}
</code></pre></div><h2 id=v-凸多边形最优三角剖分>V. 凸多边形最优三角剖分</h2><h2 id=vi-0-1背包问题>VI. 0-1背包问题</h2><blockquote><p>利用等长向量来表示状态</p></blockquote></div><div class=btn-improve-page><a href=https://github.com/ztqakita/ztqakita.github.io/edit//content/posts/algorithms/Algorithm_analysis-2.md><i class="fas fa-code-branch"></i>Improve this page</a></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/operating-system/operating_system_concepts_3/ class="btn btn-outline-info"><span><i class="fas fa-chevron-circle-left"></i>Prev</span><br><span>CPU Scheduling</span></a></div><div class="col-md-6 next-article"><a href=/posts/operating-system/operating_system_concepts_2/ class="btn btn-outline-info"><span>Next <i class="fas fa-chevron-circle-right"></i></span><br><span>Process & Threads</span></a></div></div><hr></div></div></div><a id=scroll-to-top class=btn><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#i-基本思想>I. 基本思想</a></li><li><a href=#ii-矩阵连乘问题>II. 矩阵连乘问题</a></li><li><a href=#iii-最长公共子序列>III. 最长公共子序列</a></li><li><a href=#iv-最大子段和>IV. 最大子段和</a></li><li><a href=#v-凸多边形最优三角剖分>V. 凸多边形最优三角剖分</a></li><li><a href=#vi-0-1背包问题>VI. 0-1背包问题</a></li></ul></nav></div></div></section></div><footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=#about>About</a></li><li class=nav-item><a class=smooth-scroll href=#skills>Skills</a></li><li class=nav-item><a class=smooth-scroll href=#experiences>Experiences</a></li><li class=nav-item><a class=smooth-scroll href=#projects>Projects</a></li><li class=nav-item><a class=smooth-scroll href=#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=#achievements>Achievements</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><span>Email:</span> <span>ztqakita@163.com</span></li><li><span>Phone:</span> <span>(+86)18618180071</span></li></ul></div><div class="col-md-4 col-sm-12"><p>Stay up to date with email notification</p><form><div class=form-group><input type=email class=form-control id=exampleInputEmail1 aria-describedby=emailHelp placeholder="Enter email">
<small id=emailHelp class="form-text text-muted">By entering your email address, you agree to receive the newsletter of this website.</small></div><button type=submit class="btn btn-info">Submit</button></form></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=#><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_2.png>
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/js/jquery-3.4.1.min.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/navbar.js></script><script src=/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script><script src=/js/single.js></script><script>hljs.initHighlightingOnLoad()</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:!0,processEnvironments:!0,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var b=MathJax.Hub.getAllJax(),a;for(a=0;a<b.length;a+=1)b[a].SourceElement().parentNode.className+=' has-jax'}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></body></html>