<!doctype html><html><head><title>Posts</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/layouts/main.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/navigators/navbar.css><link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/layouts/list.css><link rel=stylesheet href=/css/navigators/sidebar.css></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png>ztqakita's Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png class=d-none id=main-logo>
<img src=/images/inverted-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png class=d-none id=inverted-logo></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=https://ztqakita.github.io/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><a href=/posts/introduction/>Introduction</a></li><li><i class="fas fa-plus-circle"></i><a href=/posts/algorithms/>Algorithms</a><ul><li><a href=/posts/algorithms/algorithm_analysis-1/>Complexity & Divide and Conquer</a></li><li><a href=/posts/algorithms/algorithm_analysis-2/>Dynamic Programming</a></li><li><a href=/posts/algorithms/algorithm_analysis-3/>Greedy & Back-track & Branch and Bound</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/compiler/>Compiler</a><ul><li><a href=/posts/compiler/compilers_1/>Lexcial Analysis & Parsing</a></li><li><a href=/posts/compiler/compilers_3/>Semantic Analysis & Runtime Environment</a></li><li><a href=/posts/compiler/compilers_2/>Syntax-directed Translation</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/database-system/>Database System</a><ul><li><a href=/posts/database-system/database_system_1/>Database System Lecture Note 1</a></li><li><a href=/posts/database-system/database_system_2/>Database System Lecture Note 2</a></li><li><a href=/posts/database-system/database_system_3/>Database System Lecture Note 3</a></li><li><a href=/posts/database-system/database_system_4/>Database System Lecture Note 4</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/deep-learning/>DL</a><ul><li><a href=/posts/deep-learning/cnn/>Convolutional Neural Network</a></li><li><a href=/posts/deep-learning/introduction-to-deep-learning/>Introduction to Deep Learning</a></li><li><a href=/posts/deep-learning/optimizer-for-dl/>Optimization for Deep Learning</a></li><li><a href=/posts/deep-learning/rnn/>Recursive Neural Network</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/machine-learning/>ML</a><ul><li><a href=/posts/machine-learning/basic-concepts/>Basic Concepts</a></li><li><a href=/posts/machine-learning/classification/>Classification</a></li><li><a href=/posts/machine-learning/perceptron/>Perceptron</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/operating-system/>Operating System</a><ul><li><a href=/posts/operating-system/operating_system_concepts_3/>CPU Scheduling</a></li><li><a href=/posts/operating-system/operating_system_concepts_6/>File System</a></li><li><a href=/posts/operating-system/operating_system_concepts_1/>Introduction & OS Structure</a></li><li><a href=/posts/operating-system/operating_system_concepts_7/>Mass-Storage Structure & I/O System</a></li><li><a href=/posts/operating-system/operating_system_concepts_5/>Memory Management</a></li><li><a href=/posts/operating-system/operating_system_concepts_2/>Process & Threads</a></li><li><a href=/posts/operating-system/operating_system_concepts_4/>Process Synchronization</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class="content container-fluid" id=content><div class="container-fluid post-card-holder" id=post-card-holder><div class=post-card><a href=/posts/operating-system/operating_system_concepts_4/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Process Synchronization</h5><p class="card-text post-summary">Chapter 6 Process Synchronization 6.1 Background 6.1.1 Shared resources Def:
the resources (e.g., data, CPU, I/O ports, memory) that can be accessed by several cooperating processes concurrently the shared resources cannot be used by several processes simultaneously (or in parallel), only be used mutual exclusively(互斥) 信号量的三种用法：
资源互斥使用：资源只有1个实例，各个进程通过二元信号量mutex互斥地进入临界区，使用资源。 Mutex：代表资源的控制权，初值为1。 mutex = 1：buffer空闲 mutex = 0：buffer阻塞 资源竞争使用： 资源有多个实例，允许多个进程竞争使用资源。 多元信号量表示：(1)资源可用数目，(2)资源使用权 e.g. empty, full 进程间同步： 进程间的执行步骤需要有先后顺序关系 同步二元信号sync，初值为0 sync = 0：未开始跑 sync = 1：前面进程跑完 6.</p></div><div class=card-footer><span class=float-left>October 14, 2020</span>
<a href=/posts/operating-system/operating_system_concepts_4/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/operating-system/operating_system_concepts_3/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>CPU Scheduling</h5><p class="card-text post-summary">Chapter 5 CPU Scheduling 5.1 Concepts on Scheduling 5.1.1 basic concepts CPU Scheduling: (短期调度) ==selecting + allocating + enabling, in kernel mode.== The procedure of selecting running entities in main memory ( i.e., processes or threads in the ready queue) according to some criteria, allocating CPU to the selected running entities, and then enabling them to run on CPU
CPU burst occurs: running state
I/O burst occurs: waiting state</p></div><div class=card-footer><span class=float-left>October 12, 2020</span>
<a href=/posts/operating-system/operating_system_concepts_3/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/algorithms/algorithm_analysis-2/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Dynamic Programming</h5><p class="card-text post-summary">Chapter 3 Dynamic Programming I. 基本思想 聪明的遍历方法 为全遍历，不同于贪心算法的单一路径 关键：==自底向上== 寻找最优子结构： ==该问题的最优解包含着其子问题的最优解== 验证方法：反证法 建立递推关系 II. 矩阵连乘问题 最优解 == 以最少的数乘次数计算出矩阵连乘的乘积
引子想法：改进分治法 原本的分治法： 通过递归树，可以发现在递归中经常会重复计算： 思路是将重复计算的部分存储进二维数组之中，这种方法是基于分治法的改进方法 int LookupChain(int i，int j) { if (m[i][j] > 0) return m[i][j]; if (i == j) return 0; int u = LookupChain(i，i) + LookupChain(i+1，j) + p[i-1]*p[i]*p[j]; s[i][j] = i; for (int k = i+1; k &lt; j; k++) { int t = LookupChain(i，k) + LookupChain(k+1，j) + p[i-1]*p[k]*p[j]; if (t &lt; u) { u = t; s[i][j] = k; } } m[i][j] = u; return u; } 动态规划法 动态规划先从最小的子问题开始计算，==自底向上==进行合并运算。这种方法不需要递归，而且也可以避免重复计算。 (1) 分析最优子结构 原问题的最优解可以由子问题的最优解解决，对于动态规划问题，首先需要证明该问题==满足最优子结构性质==(利用反证法) 矩阵连乘问题符合最优子结构的证明： 假设$A[i:j]=A[i:k]+A[k+1:j]$是最小的计算量，且有$A[i:m]+A[m+1:j] &lt; A[i:k]+A[k+1:j]$，则可以发现原$A[i:j] &lt; A[i:m]+A[m+1:j]$，此时不满足假设条件，矛盾！</p></div><div class=card-footer><span class=float-left>October 5, 2020</span>
<a href=/posts/algorithms/algorithm_analysis-2/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/operating-system/operating_system_concepts_2/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Process & Threads</h5><p class="card-text post-summary">Chapter 3: Process 3.1 Process Concept 3.1.1 Process Definition A process is
a program in execution the unit of resources (CPU, memory, I/O devices) allocation runs concurrently with other processes Another definition: 具有一定独立功能的某个程序关于某个数据集合的一次运行活动。是系统进行资源分配和调度的独立单位。(又称task，job)
进程的特点：
动态性：可动态地创建、结束进程 并发性：进程可以被独立调度并占用处理机运行(并发&并行) 独立性：不同进程的工作不相互影响 制约性：因访问共享数据/资源或进程同步而产生制约(进程之间有交互、共享等情况) Process = program + data + PCB. 3.1.2 Process State A process is dynamic, and has its lifetime. As a process executes, it changes among the following states: new: the process is being created.</p></div><div class=card-footer><span class=float-left>September 28, 2020</span>
<a href=/posts/operating-system/operating_system_concepts_2/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/compiler/compilers_1/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Lexcial Analysis & Parsing</h5><p class="card-text post-summary">I. 词法分析 词法分析器作用：
扫描源程序字符流 按照源语言的词法规则识别出各类单词符号 产生用于语法分析的记号序列 词法检查 创建符号表 &mdash; 为语法分析使用 接口：跳过注释、标注错误信息 一、词法分析程序与语法分析程序的关系 1.1 词法分析程序作为独立的一遍 1.2 词法分析程序作为语法分析程序的子程序 词法分析相当于函数，语法分析每一次需要记号时即调用词法分析函数获得记号。 这种操作的好处可以避免中间文件、省去取送记号的工作。
1.3 词法分析程序与语法分析程序作为协同程序 这种方法不常用。
二、词法分析程序的输入与输出 2.1 配对缓冲区 哨兵！！！(EOF)
把一个缓冲器分为大小相同的两半，每半各含N个字符，一般N=1KB或4KB。为了使得判断更为优化，在每个半区后面加上EOF。 这种做法是为了让缓冲区可以处理超出其范围的字符串。
2.2 词法分析程序的输出——记号 记号：某一类单词符号的类别编码，如id，num 模式：某一类单词符号的构成规则，如“有字母开头的字母字符串” 单词：某一类单词符号的具体实例，如hello 记号的属性 作用：记号影响语法分析的决策，属性影响记号的翻译。 三、记号的描述和识别 3.1 词法与正规文法 描述语言的标识符、常数、运算符和标点符号等记号的文法
3.2 记号的文法 标识符 描述标识符集合的正则表达式： 标识符的正规文法(右线性文法) 常数 整数 描述整数结构的正则表达式：
无符号数
运算符 分界符 关键字 四、词法分析程序的设计与实现 五、软件工具LEX II.</p></div><div class=card-footer><span class=float-left>September 22, 2020</span>
<a href=/posts/compiler/compilers_1/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/algorithms/algorithm_analysis-1/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Complexity & Divide and Conquer</h5><p class="card-text post-summary">Chapter 1 I. 算法及算法复杂度 1. Definition Input Output Definiteness Finiteness Effectiveness note: program vs algorithm program: A program is written in some programming language, and does not have to be finite. algorithm: An algorithm can be described by human languages, flow charts, some programming languages, or pseudo-code.
2. 算法的评价 正确性 健壮性 复杂性 时间复杂度 空间复杂度 可读性 简单性 II. 算法复杂度分析 1. 指标 平均时间复杂度 最坏时间复杂度 2.</p></div><div class=card-footer><span class=float-left>September 21, 2020</span>
<a href=/posts/algorithms/algorithm_analysis-1/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/operating-system/operating_system_concepts_1/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Introduction & OS Structure</h5><p class="card-text post-summary">Chapter 1: Introduction 1.1 OS Definition A program that acts as an intermediary between a user of a computer and the computer hardware.
Computer System Structure 1.1.1 User View ease of use Do not care about resource utilization! 1.1.2 System View resourse allocator control program 1.2 Computer-System Organization bootstrap program: Typically stored in ROM or EPROM, generally known as firmware. Initializes all aspects of system. Loads operating system kernel and starts execution.</p></div><div class=card-footer><span class=float-left>September 21, 2020</span>
<a href=/posts/operating-system/operating_system_concepts_1/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/database-system/database_system_1/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Database System Lecture Note 1</h5><p class="card-text post-summary">Chapter 1 Introduction 1.1 DB, DBMS, DBS, DBAS DB: a collection of interrelated data stored in systems as files DBMS: a set of programs to access the data in DB DBS: users + DBMS + DB 1.2 View of Data 1.2.1 Levels of Data Abstraction View Level: how the data items in DB are used by different users Logical Level: e.</p></div><div class=card-footer><span class=float-left>September 15, 2020</span>
<a href=/posts/database-system/database_system_1/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/deep-learning/cnn/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Convolutional Neural Network</h5><p class="card-text post-summary">I. CNN Structure Overview II. Convolution Note: 1.Every elements in filter are the network parameter to be learned. 2.Stride means each step you walk from previous position. 3.The size of filter is decided by programmer.
From the picture we could know the largest values of Feature Map means there has a feature. Then we do the same process for every filter and generate more Feature Map.
If we deal with colorful image, we will use Filter Cube instead of matrix.</p></div><div class=card-footer><span class=float-left>September 14, 2020</span>
<a href=/posts/deep-learning/cnn/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/deep-learning/introduction-to-deep-learning/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Introduction to Deep Learning</h5><p class="card-text post-summary">I. Basic Concepts 1. Fully Connected Feedforward Network 2. Matrix Operation Every layer has weight matrix and bias matrix, using matrix operation we can accumulate the output matrix $y$. Tips: Using GPU could speed up matrix operation.
II. Why Deep Learning? 1. Modularization 对neural network而言，并不是神经元越多越好，通过例子可以看出层数的增加（more deep）对于准确率的提升更有效果。这其中就是 Modularization 的思想。For example, while you are trying to train the model below, you can use basic classifiers as module. Each basic classifier can have sufficient training examples.</p></div><div class=card-footer><span class=float-left>August 10, 2020</span>
<a href=/posts/deep-learning/introduction-to-deep-learning/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/machine-learning/classification/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Classification</h5><p class="card-text post-summary">Classification I. Probabilistic Generative Models 1. Detailed Process The basic idea is estimating the probabilities form training data. Let&rsquo;s consider the two classes case: First of all, we need to figure out prior class probabilities $P(C_k)$. It&rsquo;s pretty easy to find that $P(C_k) = \frac{SizeOf C_k}{SizeOf Training Data}$ Then the task is to find out $P(x|C_k)$. Each data is represented as a vector by its attribute, and it exist as a point in a multidimensional space.</p></div><div class=card-footer><span class=float-left>July 28, 2020</span>
<a href=/posts/machine-learning/classification/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div><div class=post-card><a href=/posts/deep-learning/optimizer-for-dl/ class=post-card-link><div class=card><div class=card-head><img class=card-img-top src=/images/default-hero.jpg></div><div class=card-body><h5 class=card-title>Optimization for Deep Learning</h5><p class="card-text post-summary">Some Notation: $\theta_t$: model parameter at time step t $\nabla$$L(\theta_t)$ or $g_t$: gradient at $\theta_t$, used to compute $\theta_{t+1}$ $m_{t+1}$: momentum accumlated from time step 0 to time step t, which is used to compute $\theta_{t+1}$
I. Adaptive Learning Rates In gradient descent, we need to set the learning rate to converge properly and find the local minima. But sometimes it&rsquo;s difficult to find a proper value of the learning rate.</p></div><div class=card-footer><span class=float-left>July 25, 2020</span>
<a href=/posts/deep-learning/optimizer-for-dl/ class="float-right btn btn-outline-info btn-sm">Read</a></div></div></a></div></div><div class=paginator><ul class=pagination><li class=page-item><a href=/posts/ class=page-link aria-label=First><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/ class=page-link aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a class=page-link href=/posts/>1</a></li><li class="page-item active"><a class=page-link href=/posts/page/2/>2</a></li><li class=page-item><a class=page-link href=/posts/page/3/>3</a></li><li class=page-item><a href=/posts/page/3/ class=page-link aria-label=Next><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/3/ class=page-link aria-label=Last><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div></section></div><footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=#about>About</a></li><li class=nav-item><a class=smooth-scroll href=#skills>Skills</a></li><li class=nav-item><a class=smooth-scroll href=#experiences>Experiences</a></li><li class=nav-item><a class=smooth-scroll href=#projects>Projects</a></li><li class=nav-item><a class=smooth-scroll href=#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=#achievements>Achievements</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><span>Email:</span> <span>ztqakita@163.com</span></li><li><span>Phone:</span> <span>(+86)18618180071</span></li></ul></div><div class="col-md-4 col-sm-12"><p>Stay up to date with email notification</p><form><div class=form-group><input type=email class=form-control id=exampleInputEmail1 aria-describedby=emailHelp placeholder="Enter email">
<small id=emailHelp class="form-text text-muted">We'll never share your email with anyone else.</small></div><button type=submit class="btn btn-info">Submit</button></form></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=#><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_2.png>
Toha</a></div><div class="col-md-4 text-center">© 2020 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/js/jquery-3.4.1.min.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/navbar.js></script><script src=/js/main.js></script><script src=/js/list.js></script></body></html>