<!doctype html><html><head><title>Lexcial Analysis & Parsing</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/layouts/main.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/navigators/navbar.css><link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png><link rel=stylesheet href=/css/style.css><meta name=description content="Lexcial Analysis & Parsing"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css><link rel=stylesheet href=/css/layouts/single.css><link rel=stylesheet href=/css/navigators/sidebar.css></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png>ztqakita's Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png class=d-none id=main-logo>
<img src=/images/inverted-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png class=d-none id=inverted-logo></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=https://ztqakita.github.io/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><a href=/posts/introduction/>Introduction</a></li><li><i class="fas fa-plus-circle"></i><a href=/posts/algorithms/>Algorithms</a><ul><li><a href=/posts/algorithms/algorithm_analysis-1/>Complexity & Divide and Conquer</a></li><li><a href=/posts/algorithms/algorithm_analysis-2/>Dynamic Programming</a></li><li><a href=/posts/algorithms/algorithm_analysis-3/>Greedy & Back-track & Branch and Bound</a></li></ul></li><li><i class="fas fa-minus-circle"></i><a class=active href=/posts/compiler/>Compiler</a><ul class=active><li><a class=active href=/posts/compiler/compilers_1/>Lexcial Analysis & Parsing</a></li><li><a href=/posts/compiler/compilers_3/>Semantic Analysis & Runtime Environment</a></li><li><a href=/posts/compiler/compilers_2/>Syntax-directed Translation</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/neural-computation/>Computational Neuroscience</a><ul><li><a href=/posts/neural-computation/1-ionic_currents/>Ionic Currents</a></li><li><a href=/posts/neural-computation/basic-neuro-knowledge/>Neuroscience Basic Knowledge</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/database-system/>Database System</a><ul><li><a href=/posts/database-system/database_system_1/>Database System Lecture Note 1</a></li><li><a href=/posts/database-system/database_system_2/>Database System Lecture Note 2</a></li><li><a href=/posts/database-system/database_system_3/>Database System Lecture Note 3</a></li><li><a href=/posts/database-system/database_system_4/>Database System Lecture Note 4</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/deep-learning/>DL</a><ul><li><a href=/posts/deep-learning/cnn/>Convolutional Neural Network</a></li><li><a href=/posts/deep-learning/introduction-to-deep-learning/>Introduction to Deep Learning</a></li><li><a href=/posts/deep-learning/optimizer-for-dl/>Optimization for Deep Learning</a></li><li><a href=/posts/deep-learning/rnn/>Recursive Neural Network</a></li><li><a href=/posts/deep-learning/self-attention/>Self-attention</a></li><li><a href=/posts/deep-learning/transformer/>Transformer</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/life-learning/>Life Learning</a><ul><li><a href=/posts/life-learning/lecture_james_mcclleland/>Lecture James McClleland</a></li><li><a href=/posts/life-learning/lecture_yao_xin/>Lecture Yao Xin</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/machine-learning/>ML</a><ul><li><a href=/posts/machine-learning/basic-concepts/>Basic Concepts</a></li><li><a href=/posts/machine-learning/classification/>Classification</a></li><li><a href=/posts/machine-learning/decision-tree/>Decision Tree</a></li><li><a href=/posts/machine-learning/knn/>KNN</a></li><li><a href=/posts/machine-learning/perceptron/>Perceptron</a></li><li><a href=/posts/machine-learning/support-vector/>Support Vector Machines</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/operating-system/>Operating System</a><ul><li><a href=/posts/operating-system/operating_system_concepts_3/>CPU Scheduling</a></li><li><a href=/posts/operating-system/operating_system_concepts_6/>File System</a></li><li><a href=/posts/operating-system/operating_system_concepts_1/>Introduction & OS Structure</a></li><li><a href=/posts/operating-system/operating_system_concepts_7/>Mass-Storage Structure & I/O System</a></li><li><a href=/posts/operating-system/operating_system_concepts_5/>Memory Management</a></li><li><a href=/posts/operating-system/operating_system_concepts_2/>Process & Threads</a></li><li><a href=/posts/operating-system/operating_system_concepts_4/>Process Synchronization</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/paper-reading/>Paper Reading</a><ul><li><a href=/posts/paper-reading/integrated_understanding_system/>Integrated understanding system</a></li><li><a href=/posts/paper-reading/push-pull_feedback/>Push-pull feedback</a></li><li><a href=/posts/paper-reading/reservoir_decision_making/>reservoir decision making network</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(https://ztqakita.github.io/images/default-hero.jpg)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/images/author/ztq.png><h5 class=author-name>Brandon Zhang</h5><p>September 22, 2020</p></div><div class=title><h1>Lexcial Analysis & Parsing</h1></div><div class=post-content id=post-content><h1 id=i-词法分析>I. 词法分析</h1><p>词法分析器作用：</p><ol><li><strong>扫描</strong>源程序字符流</li><li>按照源语言的词法规则<strong>识别</strong>出各类单词符号</li><li>产生用于语法分析的<strong>记号序列</strong></li><li>词法检查</li><li>创建符号表 &mdash; 为<strong>语法分析</strong>使用</li><li>接口：跳过注释、标注错误信息</li></ol><h2 id=一词法分析程序与语法分析程序的关系>一、词法分析程序与语法分析程序的关系</h2><h3 id=11-词法分析程序作为独立的一遍>1.1 词法分析程序作为独立的一遍</h3><p><img src=/images/posts/compiler/1.JPG alt></p><h3 id=12-词法分析程序作为语法分析程序的子程序>1.2 词法分析程序作为语法分析程序的子程序</h3><p>词法分析相当于函数，语法分析每一次需要记号时即调用词法分析函数获得记号。
<img src=/images/posts/compiler/2.JPG alt></p><blockquote><p>这种操作的好处可以避免中间文件、省去取送记号的工作。</p></blockquote><h3 id=13-词法分析程序与语法分析程序作为协同程序>1.3 词法分析程序与语法分析程序作为协同程序</h3><p>这种方法不常用。</p><h2 id=二词法分析程序的输入与输出>二、词法分析程序的输入与输出</h2><h3 id=21-配对缓冲区>2.1 配对缓冲区</h3><blockquote><p>哨兵！！！(EOF)</p></blockquote><p>把一个缓冲器分为大小相同的两半，每半各含N个字符，一般N=1KB或4KB。为了使得判断更为优化，在每个半区后面加上EOF。
<img src=/images/posts/compiler/3.JPG alt>
这种做法是为了让缓冲区可以处理超出其范围的字符串。</p><h3 id=22-词法分析程序的输出记号>2.2 词法分析程序的输出——记号</h3><ol><li>记号：某一类单词符号的类别编码，如id，num</li><li>模式：某一类单词符号的构成规则，如“有字母开头的字母字符串”</li><li>单词：某一类单词符号的具体实例，如hello</li></ol><ul><li>记号的属性<ul><li>作用：<em><strong>记号影响语法分析的决策，属性影响记号的翻译。</strong></em>
<img src=/images/posts/compiler/4.JPG alt></li></ul></li></ul><h2 id=三记号的描述和识别>三、记号的描述和识别</h2><h3 id=31-词法与正规文法>3.1 词法与正规文法</h3><p>描述语言的标识符、常数、运算符和标点符号等记号的文法</p><h3 id=32-记号的文法>3.2 记号的文法</h3><ol><li>标识符
描述标识符集合的正则表达式：
<img src=/images/posts/compiler/5.JPG alt>
标识符的正规文法(右线性文法)
<img src=/images/posts/compiler/6.JPG alt></li><li>常数<ul><li><p>整数
描述整数结构的正则表达式：</p></li><li><p>无符号数</p></li></ul></li><li>运算符</li><li>分界符</li><li>关键字</li></ol><h2 id=四词法分析程序的设计与实现>四、词法分析程序的设计与实现</h2><h2 id=五软件工具lex>五、软件工具LEX</h2><h1 id=ii-语法分析>II. 语法分析</h1><h2 id=一简介>一、简介</h2><ol><li>语法分析程序的任务</li></ol><ul><li>从源程序<strong>记号序列</strong>中识别出各类语法成分</li><li>进行语法检查</li></ul><ol start=2><li>三种分析器的关系
<img src=/images/posts/compiler/10.JPG alt></li><li>语法分析程序的作用</li></ol><ul><li>输入：记号流/记号序列</li><li>工作依据：语法规则</li><li>功能：将记号组合成语法成分、语法检查</li><li>输出：<strong>分析树</strong></li><li>错误处理</li></ul><ol start=4><li>常用的分析方法：</li></ol><ul><li>自顶向下的分析方法</li><li>自底向上的分析方法</li></ul><blockquote><p>对输入符号串的扫描顺序：==自左向右==</p></blockquote><ol start=5><li>错误恢复策略：</li></ol><ul><li>紧急方式恢复：
抛弃出错的语法结构，方法简单，不会陷入死循环</li><li>短语级恢复：
局部纠错，防止发生死循环</li><li>出错产生式：
扩充文法，增加产生错误的产生式</li><li>全局纠错：
时空代价太大，只有理论上的意义</li></ul><h2 id=二自顶向下分析方法>二、自顶向下分析方法</h2><h3 id=1-递归下降分析>1. 递归下降分析</h3><p>为输入符号串建立一个<strong>最左推导序列</strong>的过程</p><ul><li>文法的==每一个非终结符号对应一个递归过程==，即可实现这种带回溯的递归下降分析方法。</li><li>每个过程作为一个布尔过程，一旦发现它的某个产生式与输入串匹配，则用该产生式展开分析树，并返回true，否则分析树不变，返回false。</li></ul><p>问题：回溯、穷举</p><h3 id=2-递归调用预测分析>2. 递归调用预测分析</h3><ol><li><p>如何克服回溯
让每一个候选式的开始符号各不相同</p></li><li><p>对文法的要求</p><blockquote><p><img src=/images/posts/compiler/11.JPG alt></p></blockquote><ul><li>文法不含左递归</li><li>非终结符号A的所有候选式的首符集两两互不相交</li></ul></li><li><p>预测分析程序的构造</p><ul><li>预测分析程序的转换图</li><li>转换图的工作过程
<img src=/images/posts/compiler/12.JPG alt></li><li>转换图的化简</li><li>预测分析程序的实现<ul><li>如果是终结符，则程序为==匹配该终结符==，输入指针移向下一个记号</li><li>如果是非终结符，则程序为==调用==该非终结符所对应的子程序，输入指针不移动</li><li>如果有两个以上的射出边，则使用==分枝语句==在程序中产生相应的分支部分</li></ul></li></ul></li><li><p><strong>LL(1)文法</strong>
(1) <strong>FIRST集合的构造</strong>
(2) <strong>FOLLOW集合的构造</strong>
(3) <strong>LL(1)文法的定义</strong>
<img src=/images/posts/compiler/13.JPG alt></p></li></ol><h3 id=3-非递归预测分析>3. 非递归预测分析</h3><p>使用一张<strong>分析表</strong>和一个<strong>栈</strong>联合控制，实现对输入符号串的自顶向下分析。</p><ol><li><strong>预测分析程序的模型及工作过程</strong></li></ol><blockquote><p>判断LL(1)文法的标准，用第一种方法更为简单</p></blockquote><p>关键：决定哪个产生式运用于非终结符
模型:
<img src=/images/posts/compiler/14.JPG alt></p><ol start=2><li><p><strong>预测分析控制程序</strong>
==这个程序的执行直接看作业例题。==</p></li><li><p><strong>预测分析表的构造方法</strong>
<img src=/images/posts/compiler/15.JPG alt></p></li><li><p><strong>预测分析方法中的错误处理示例</strong></p></li></ol><ul><li>栈顶终结符与输入串的首字符不匹配：
解决方法：弹出栈顶的终结符号</li><li>寻找的分析表表项为空：
解决方法：跳过剩余输入符号串中的若干个符号，直到可以继续进行分析为止(相当于丢掉该非终结符带来的一个树分支)</li></ul><ol start=5><li><strong>带有同步化信息的分析表</strong>
<img src=/images/posts/compiler/16.JPG alt>
==相当于通过FOLLOW集进行判断，若表项没有就加上synch==</li></ol><h2 id=三自底向上分析方法>三、自底向上分析方法</h2><p>“可归约串”是句型的“最左素短语”。</p><ul><li>素短语：句型的一个短语，至少含有一个终结符号，并且除它自身之外不再含有其他更小的素短语。</li><li>最左素短语：处于句型最左边的那个素短语。</li></ul><h3 id=1-移进-归约分析方法>1. <strong>“移进-归约”分析方法</strong></h3><ul><li>符号栈：存放文法符号</li><li>分析过程：
（1）把输入符号一个个地移进栈中。
（2）当栈顶的符号串<strong>形成某个产生式的一个候选式</strong>时，在一定条件下，把该符号串替换(即归约)为该产生式的左部符号。
（3）重复(2)，直到栈顶符号串不再是“可归约串”为止。
（4）重复(1)-(3)，直到最终归约出文法开始符号S。</li></ul><h3 id=2-规范规约>2. <strong>规范规约</strong></h3><p>最右推导的逆过程
<img src=/images/posts/compiler/17.JPG alt></p><p>最右推导又称<strong>规范推导</strong>，由最右推导得到的右句型也称为<strong>规范句型</strong>，规范推导的逆过程成为<strong>规范归约/最左规约</strong>。</p><p>规范规约的中心问题:如何寻找或确定一个右句型的句柄。</p><blockquote><p>规范句型的特点：句柄之后没有非终结符号</p></blockquote><h3 id=3-移进-归约方法实现>3. “移进-归约”方法实现</h3><p><img src=/images/posts/compiler/18.JPG alt></p><ul><li>移进：把下一个输入符号移进到栈顶。</li><li>归约：用适当的归约符号去替换这个串。</li><li>接受：宣布分析成功，停止分析。</li><li>错误处理：调用错误处理程序进行诊断和恢复。</li></ul><p>两种冲突：</p><ul><li>“移进-归约”冲突</li><li>“归约-归约”冲突</li></ul><h3 id=4-lr分析方法>4. LR分析方法</h3><h4 id=41-lr分析程序>4.1 LR分析程序</h4><ol><li>LR分析程序的模型
<img src=/images/posts/compiler/19.JPG alt></li></ol><blockquote><p>这里需注意栈的存放方式是底$S_0X_1S_1…X_mS_m$顶</p></blockquote><ol start=2><li>分析表的结构</li></ol><ul><li>状态转换表$goto[S_m，X]$</li><li>动作表$action[S_m，a_i]$</li></ul><ol start=3><li>构造LR分析表的三种技术</li></ol><ul><li>简单的LR方法（SLR)：易于实现，功能较弱</li><li>规范的LR方法（LR(1))：功能最强，代价最大</li><li>向前看的LR方法（LALR)：功能和代价介于两者之间，能分析大多数程序设计语言的结构，并且能比较有效地实现</li></ul><ol start=4><li>LR分析控制程序</li></ol><ul><li>活前缀：一个规范句型的一个前缀，如果不含句柄之后的任何符号，则称它为该句型的一个活前缀。
<img src=/images/posts/compiler/20.JPG alt></li></ul><blockquote><p>该程序具体执行结合作业和例子进行复习</p></blockquote><h4 id=42-lr分析表构造>4.2 LR分析表构造</h4><ol><li>SLR(1)分析表的构造
中心思想：为给定的文法构造一个识别它所有==活前缀==的DFA</li></ol></div><div class=btn-improve-page><a href=https://github.com/ztqakita/ztqakita.github.io/edit//content/posts/compiler/Compilers_1.md><i class="fas fa-code-branch"></i>Improve this page</a></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/operating-system/operating_system_concepts_2/ class="btn btn-outline-info"><span><i class="fas fa-chevron-circle-left"></i>Prev</span><br><span>Process & Threads</span></a></div><div class="col-md-6 next-article"><a href=/posts/algorithms/algorithm_analysis-1/ class="btn btn-outline-info"><span>Next <i class="fas fa-chevron-circle-right"></i></span><br><span>Complexity & Divide and Conquer</span></a></div></div><hr></div></div></div><a id=scroll-to-top class=btn><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#一词法分析程序与语法分析程序的关系>一、词法分析程序与语法分析程序的关系</a><ul><li><a href=#11-词法分析程序作为独立的一遍>1.1 词法分析程序作为独立的一遍</a></li><li><a href=#12-词法分析程序作为语法分析程序的子程序>1.2 词法分析程序作为语法分析程序的子程序</a></li><li><a href=#13-词法分析程序与语法分析程序作为协同程序>1.3 词法分析程序与语法分析程序作为协同程序</a></li></ul></li><li><a href=#二词法分析程序的输入与输出>二、词法分析程序的输入与输出</a><ul><li><a href=#21-配对缓冲区>2.1 配对缓冲区</a></li><li><a href=#22-词法分析程序的输出记号>2.2 词法分析程序的输出——记号</a></li></ul></li><li><a href=#三记号的描述和识别>三、记号的描述和识别</a><ul><li><a href=#31-词法与正规文法>3.1 词法与正规文法</a></li><li><a href=#32-记号的文法>3.2 记号的文法</a></li></ul></li><li><a href=#四词法分析程序的设计与实现>四、词法分析程序的设计与实现</a></li><li><a href=#五软件工具lex>五、软件工具LEX</a></li></ul><ul><li><a href=#一简介>一、简介</a></li><li><a href=#二自顶向下分析方法>二、自顶向下分析方法</a><ul><li><a href=#1-递归下降分析>1. 递归下降分析</a></li><li><a href=#2-递归调用预测分析>2. 递归调用预测分析</a></li><li><a href=#3-非递归预测分析>3. 非递归预测分析</a></li></ul></li><li><a href=#三自底向上分析方法>三、自底向上分析方法</a><ul><li><a href=#1-移进-归约分析方法>1. <strong>“移进-归约”分析方法</strong></a></li><li><a href=#2-规范规约>2. <strong>规范规约</strong></a></li><li><a href=#3-移进-归约方法实现>3. “移进-归约”方法实现</a></li><li><a href=#4-lr分析方法>4. LR分析方法</a><ul><li><a href=#41-lr分析程序>4.1 LR分析程序</a></li><li><a href=#42-lr分析表构造>4.2 LR分析表构造</a></li></ul></li></ul></li></ul></nav></div></div></section></div><footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=#about>About</a></li><li class=nav-item><a class=smooth-scroll href=#skills>Skills</a></li><li class=nav-item><a class=smooth-scroll href=#experiences>Experiences</a></li><li class=nav-item><a class=smooth-scroll href=#projects>Projects</a></li><li class=nav-item><a class=smooth-scroll href=#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=#achievements>Achievements</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><span>Email:</span> <span>ztqakita@163.com</span></li><li><span>Phone:</span> <span>(+86)18618180071</span></li></ul></div><div class="col-md-4 col-sm-12"><p>Stay up to date with email notification</p><form><div class=form-group><input type=email class=form-control id=exampleInputEmail1 aria-describedby=emailHelp placeholder="Enter email">
<small id=emailHelp class="form-text text-muted">We'll never share your email with anyone else.</small></div><button type=submit class="btn btn-info">Submit</button></form></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=#><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_2.png>
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/js/jquery-3.4.1.min.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/navbar.js></script><script src=/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script><script src=/js/single.js></script><script>hljs.initHighlightingOnLoad()</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:!0,processEnvironments:!0,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var b=MathJax.Hub.getAllJax(),a;for(a=0;a<b.length;a+=1)b[a].SourceElement().parentNode.className+=' has-jax'}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></body></html>