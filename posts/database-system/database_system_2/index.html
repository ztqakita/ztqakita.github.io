<!doctype html><html><head><title>Database System Lecture Note 2</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/layouts/main.css><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/navigators/navbar.css><link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css><link rel=icon type=image/png href=/images/favicon_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png><link rel=stylesheet href=/css/style.css><meta name=description content="Database System Lecture Note 2"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css><link rel=stylesheet href=/css/layouts/single.css><link rel=stylesheet href=/css/navigators/sidebar.css></head><body data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button onclick=toggleSidebar()>
<span class=navbar-toggler-icon></span></button>
<a class=navbar-brand href=/><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png>ztqakita's Blog</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button onclick=toggleTOC()>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"></ul></div></div><img src=/images/main-logo_hu864bbe108f1be1ae04b57f7f2fd9d631_5637_42x0_resize_box_2.png class=d-none id=main-logo>
<img src=/images/inverted-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_42x0_resize_box_2.png class=d-none id=inverted-logo></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=https://ztqakita.github.io/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/posts data-filter=all>Posts</a></li><div class=subtree><li><a href=/posts/introduction/>Introduction</a></li><li><i class="fas fa-plus-circle"></i><a href=/posts/algorithms/>Algorithms</a><ul><li><a href=/posts/algorithms/algorithm_analysis-1/>Complexity & Divide and Conquer</a></li><li><a href=/posts/algorithms/algorithm_analysis-2/>Dynamic Programming</a></li><li><a href=/posts/algorithms/algorithm_analysis-3/>Greedy & Back-track & Branch and Bound</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/compiler/>Compiler</a><ul><li><a href=/posts/compiler/compilers_1/>Lexcial Analysis & Parsing</a></li><li><a href=/posts/compiler/compilers_3/>Semantic Analysis & Runtime Environment</a></li><li><a href=/posts/compiler/compilers_2/>Syntax-directed Translation</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/neural-computation/>Computational Neuroscience</a><ul><li><a href=/posts/neural-computation/1-ionic_currents/>Ionic Currents</a></li><li><a href=/posts/neural-computation/basic-neuro-knowledge/>Neuroscience Basic Knowledge</a></li></ul></li><li><i class="fas fa-minus-circle"></i><a class=active href=/posts/database-system/>Database System</a><ul class=active><li><a href=/posts/database-system/database_system_1/>Database System Lecture Note 1</a></li><li><a class=active href=/posts/database-system/database_system_2/>Database System Lecture Note 2</a></li><li><a href=/posts/database-system/database_system_3/>Database System Lecture Note 3</a></li><li><a href=/posts/database-system/database_system_4/>Database System Lecture Note 4</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/deep-learning/>DL</a><ul><li><a href=/posts/deep-learning/cnn/>Convolutional Neural Network</a></li><li><a href=/posts/deep-learning/introduction-to-deep-learning/>Introduction to Deep Learning</a></li><li><a href=/posts/deep-learning/optimizer-for-dl/>Optimization for Deep Learning</a></li><li><a href=/posts/deep-learning/rnn/>Recursive Neural Network</a></li><li><a href=/posts/deep-learning/self-attention/>Self-attention</a></li><li><a href=/posts/deep-learning/transformer/>Transformer</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/life-learning/>Life Learning</a><ul><li><a href=/posts/life-learning/lecture_james_mcclleland/>Lecture James McClleland</a></li><li><a href=/posts/life-learning/lecture_yao_xin/>Lecture Yao Xin</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/machine-learning/>ML</a><ul><li><a href=/posts/machine-learning/basic-concepts/>Basic Concepts</a></li><li><a href=/posts/machine-learning/classification/>Classification</a></li><li><a href=/posts/machine-learning/decision-tree/>Decision Tree</a></li><li><a href=/posts/machine-learning/knn/>KNN</a></li><li><a href=/posts/machine-learning/perceptron/>Perceptron</a></li><li><a href=/posts/machine-learning/support-vector/>Support Vector Machines</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/operating-system/>Operating System</a><ul><li><a href=/posts/operating-system/operating_system_concepts_3/>CPU Scheduling</a></li><li><a href=/posts/operating-system/operating_system_concepts_6/>File System</a></li><li><a href=/posts/operating-system/operating_system_concepts_1/>Introduction & OS Structure</a></li><li><a href=/posts/operating-system/operating_system_concepts_7/>Mass-Storage Structure & I/O System</a></li><li><a href=/posts/operating-system/operating_system_concepts_5/>Memory Management</a></li><li><a href=/posts/operating-system/operating_system_concepts_2/>Process & Threads</a></li><li><a href=/posts/operating-system/operating_system_concepts_4/>Process Synchronization</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/posts/paper-reading/>Paper Reading</a><ul><li><a href=/posts/paper-reading/integrated_understanding_system/>Integrated understanding system</a></li><li><a href=/posts/paper-reading/push-pull_feedback/>Push-pull feedback</a></li><li><a href=/posts/paper-reading/reservoir_decision_making/>reservoir decision making network</a></li></ul></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(https://ztqakita.github.io/images/default-hero.jpg)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/images/author/ztq.png><h5 class=author-name>Brandon Zhang</h5><p>October 23, 2020</p></div><div class=title><h1>Database System Lecture Note 2</h1></div><div class=post-content id=post-content><h1 id=chapter-7-database-design-and-e-r-model>Chapter 7 Database Design and E-R Model</h1><h2 id=72-concepts>7.2 Concepts</h2><ol><li>Entity sets</li><li>Relationship sets
对于多元联系$\Rightarrow$二元联系$\Rightarrow$关系表</li><li>Attribute</li></ol><h2 id=73-constraints>7.3 Constraints</h2><ol><li>Mapping Cardinalities<ul><li>one to one</li><li>one to many</li><li>many to one</li><li>many to many</li></ul></li><li>Keys<ul><li>superkey</li><li>candidate key</li><li>primary key</li></ul></li><li></li></ol><h1 id=chapter-8-schema-normalization>Chapter 8 Schema Normalization</h1><p>核心思想：将large schemas decompose to smaller schema. 建立functional dependency, 并利用两表查询的的方式进行查询(此处详见第7章)。
在第7章通过将E-R图进行转换，得到面向特定的初始关系模式集，这些关系模式集可能存在多种数据依赖关系：</p><ul><li>Functional Dependencies</li><li>Multivalued Dependencies</li><li>Join Dependencies (略)</li></ul><p>如果直接根据初始关系模式构造DBS，由于初始关系模式中数据依赖关系的存在，可能会违反DB的完整性约束</p><ul><li>pitfalls：插入、更新、删除问题</li></ul><p>因此，对初始关系模式集，需要根据关系规范化理论，在保证关系模式的</p><ul><li>lossless join</li><li>dependency preservation</li></ul><p>步骤大致为：</p><ul><li>根据<strong>函数依赖的Armstrong’s 公理系统</strong> ( §8.4.1 )和多值依赖 的公理系统 ，从初始关系模式集中已知的函数依赖和多值依赖出发，推导出<strong>初始关系模式集中所有的函数依赖</strong>（§8.4)和多值依赖(不作要求)</li><li>模式分解算法，对其进行（等价）分解和变换，将其转换为各种范式形式。</li></ul><p><img src=/images/posts/DB/9.JPG alt>
<img src=/images/posts/DB/8.JPG alt></p><h2 id=82-atomic-domains-and-first-normal-form>8.2 Atomic Domains and First Normal Form</h2><ol><li><p><strong>Atomic Domains:</strong> its elements are considered to be indivisible units.
反例：集合(非原子域)、复合属性等</p></li><li><p><strong>First Normal Form:</strong> A relational schema R is in first normal form if the domains of all attributes of R are atomic</p></li></ol><h2 id=83-decomposition-using-functional-dependencies>8.3 Decomposition Using Functional Dependencies</h2><h3 id=831-functional-dependencies>8.3.1 Functional Dependencies</h3><ol><li><p>Def1: <em><strong>Functional dependency(FD)</strong></em> holds on R
<img src=/images/posts/DB/10.JPG alt></p></li><li><p>Keys in relational schema can be defined in terms of FD</p><ul><li>K is a <strong>superkey</strong> for relation schema R, if and only if $k \rightarrow R$</li><li>K is a <strong>candidate</strong> key for R, if and only if<ul><li>$k \rightarrow R$,</li><li>and for no $\alpha \subset K, \alpha \rightarrow R$</li></ul></li></ul></li><li><p>Def2: (A particular relation instance) r(R) satisfy FD, or FD is satisfied by r(R).</p></li></ol><blockquote><p>How to guarantee the FD in DBS?
answer：用SQL检查2个属性之间的FD</p></blockquote><ol start=4><li><p><strong>FD holds on R: 整体要求</strong>，定义在R的属性间的语义约束
<strong>FD is satisfied by r(R): 部分满足</strong>
意思是对于关系R而言，即使它的关系实例r(R)满足某些FD，也不能代表整个关系R就满足该FD！可能只是该关系实例的数据凑巧满足而已。(容易出判断题考察)</p></li><li><p>Trivial FD: 所有关系实例均满足FD，大多是右边属性包含于左边</p></li><li><p>Transitive dependency (传递函数依赖)</p></li><li><p>Partial dependency (部分函数依赖)
即对于$\alpha \rightarrow \beta$中，$\alpha$含有冗余项。</p></li><li><p><strong>Closure of FD</strong>
The set of all functional dependencies logically implied by F is the closure of F, denoted as $F^+$.</p></li></ol><h3 id=832-boyce-codd-normal-form>8.3.2 Boyce-Codd Normal Form</h3><ol><li>Def:
<img src=/images/posts/DB/11.JPG alt>
每一个FD需要满足其中之一的性质</li><li><strong>Decomposing a Schema into BCNF</strong>:
<img src=/images/posts/DB/12.JPG alt>
相当于外键关联</li></ol><p>ATTENTION：BCNF 并不能保持函数依赖，所以需要考虑上一级的3NF</p><h3 id=834-third-normal-form>8.3.4 Third Normal Form</h3><ol><li><p>Def:在BCNF的定义中添加该性质
<img src=/images/posts/DB/13.JPG alt></p></li><li><p>性质：(必要条件)</p><ul><li>R is also in 2NF</li><li>不存在<strong>非主属性</strong>对候选键的<strong>部分</strong>和<strong>传递</strong>依赖，i.e.每一个非主属性都不传递依赖于R的任何候选键</li></ul></li></ol><p><em><strong>重要！！！！</strong></em>
检测关系模式是否满足函数依赖的方法
<img src=/images/posts/DB/14.JPG alt></p><h2 id=84-functional-dependency-theory>8.4 Functional-Dependency Theory</h2><h3 id=841-closure-of-a-set-of-fd>8.4.1 Closure of a Set of FD</h3><p>定义在上面已经给出</p><ol><li><p><strong>Logically implied</strong>:
Given a schema R, a <strong>functional dependency f</strong> on R is <em><strong>logically implied</strong></em> by <strong>a set of FD</strong> F on R , if every instance r(R) that satisfies F also satisfies f.
简而言之，某个函数依赖f可以被F这个集合推出来</p></li><li><p><strong>Armstrong&rsquo;s Axioms</strong>
<img src=/images/posts/DB/15.JPG alt>
<img src=/images/posts/DB/16.JPG alt></p></li></ol><h3 id=842-closure-of-attribute-sets>8.4.2 Closure of Attribute Sets</h3><ol><li><p>Def: An attribute B is functionally determined by $\alpha$ if $\alpha \rightarrow B$.</p></li><li><p>Def
<img src=/images/posts/DB/17.JPG alt>
注意该集合是有限的</p></li><li><p>若通过某些属性推出R，说明其为superkey，接下来判断其是否是candidate key.
<img src=/images/posts/DB/18.JPG alt></p></li><li><p>Uses of Attribute Closure
<img src=/images/posts/DB/19.JPG alt>
这里的第二种用途是第二种测试函数依赖的方法，相比SQL方法更为简单方便。</p></li><li><p>等价的概念</p></li></ol><h3 id=843-canonical-cover>8.4.3 Canonical Cover</h3><p>用于去除FD set中函数依赖的左右两端的冗余项。正则覆盖是最小的与F等价的函数依赖集合，记作$F^+ = F^+_c$。
<img src=/images/posts/DB/20.JPG alt></p><ol><li><p><strong>Extraneous Attributes</strong>
<img src=/images/posts/DB/21.JPG alt></p></li><li><p>两种情况的解决问题方案</p><ul><li>当冗余元素在左边出现的时候
在原有函数依赖下，求属性闭包，用于判断冗余属性
<img src=/images/posts/DB/22.JPG alt></li><li>当冗余元素在右边出现的时候
在<strong>新的函数依赖</strong>之下求属性闭包
<img src=/images/posts/DB/23.JPG alt></li></ul></li><li><p>A canonical cover for F is a set of dependencies Fc such that
所有函数依赖的左边不会相同，这种判断方法来源于求出canonical cover的算法。</p></li><li><p>Compute a canonical cover
<img src=/images/posts/DB/24.JPG alt></p></li></ol><h3 id=844-lossless-join-decomposition>8.4.4 Lossless-join Decomposition</h3><p><img src=/images/posts/DB/25.JPG alt>
不同子表间存在外键关联。
该定理意思是对于两个关系表，他们的公共属性可以推出至少其中一张关系表的所有属性，则根据公共元素分解后的分解方式为无损分解。</p><h3 id=845-dependency-preserving>8.4.5 Dependency Preserving</h3><ol><li><p><strong>Restriction of F to Ri</strong>
<img src=/images/posts/DB/26.JPG alt></p></li><li><p><strong>Dependency Preserving</strong>
子模式FD成立可以推出原模式FD成立，用于测试dependency preserving。
<img src=/images/posts/DB/27.JPG alt></p></li></ol><p>注意以下这种情况：
<img src=/images/posts/DB/28.JPG alt>
看似$A\rightarrow D$并不能满足，但有以下关系：
$A|F_1 \rightarrow B, B|F_2 \rightarrow D$, so $A\rightarrow D$ is preserved.</p><blockquote><p>$A|F_1$ 代表在函数依赖集$F_1$下A可以推出的attributes sets</p></blockquote><h3 id=总结范式之间的关系>总结：范式之间的关系</h3><ol><li><p>Second Normal Form
<img src=/images/posts/DB/29.JPG alt>
相当于第二范式的每一个函数依赖的左边不能出现可分的超键。</p></li><li><p>Third Noramal Form
<img src=/images/posts/DB/30.JPG alt></p></li><li><p>BCNF
<img src=/images/posts/DB/31.JPG alt></p></li></ol><h2 id=85-algorithms-for-decomposition>8.5 Algorithms for Decomposition</h2><h3 id=851-bcnf-decomposition>8.5.1 BCNF Decomposition</h3><p>算法步骤如下：</p><ul><li>找出non-BCNF子模式Ri，进一步分解；</li><li><strong>求出F在Ri上的投影和该关系的候选键；</strong></li><li>Ri是non-BCNF的原因在于$\alpha \rightarrow \beta$中$\alpha$并不是superkey。</li><li>将Ri中分解成2部分，公共属性$\alpha$，其中$\alpha\rightarrow \beta$单独组成BCNF模式</li></ul><p>Note: to determine whether or not Ri is in BCNF, <strong>the restriction of F to Ri</strong> and the <strong>candidate keys of Ri</strong> should be computed !!!
在分解出新的Ri以后，首先求出F在Ri上的投影和该关系的候选键，然后再用算法进行判断</p><h3 id=852-3nf-decomposition>8.5.2 3NF Decomposition</h3><ul><li>Functional dependencies can be checked on <strong>individual relations</strong> without computing a join.</li><li>There is always a <strong>lossless-join, dependency-preserving</strong> decomposition into 3NF.</li></ul><p><img src=/images/posts/DB/32.JPG alt></p><p>Note:</p><ul><li>All candidate keys should be founded out.</li><li>Only one Fc should be computed at first</li></ul><p>如何用SQL语句表达、测试函数依赖?</p><ol><li>先分组再count，但无法找出不符合函数依赖的元组</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> b
<span style=color:#66d9ef>from</span> r
<span style=color:#66d9ef>group</span> <span style=color:#66d9ef>by</span> b
<span style=color:#66d9ef>having</span> <span style=color:#66d9ef>count</span>(<span style=color:#66d9ef>distinct</span> <span style=color:#66d9ef>c</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>
</code></pre></div><ol start=2><li>利用两表查询的方式</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>select</span> <span style=color:#f92672>?</span>
<span style=color:#66d9ef>from</span> r <span style=color:#66d9ef>as</span> T, r <span style=color:#66d9ef>as</span> S
<span style=color:#66d9ef>where</span> T.B <span style=color:#f92672>==</span> S.B <span style=color:#66d9ef>and</span> T.<span style=color:#66d9ef>C</span> <span style=color:#f92672>&lt;&gt;</span> S.<span style=color:#66d9ef>C</span>
</code></pre></div><h3 id=853-computing-of-candidate-keys>8.5.3 Computing of Candidate Keys</h3><ol><li><p>将R的所有属性分为四类：
L类：仅出现在F中函数依赖左部的属性
R类：仅出现在F中函数依赖右部的属性
N类：在F中函数依赖左右两边均未出现的属性(<strong>该属性一定为候选键</strong>)
LR类：在F中函数依赖左右两边均出现的属性</p></li><li><p>X_set代表L、N类，Y_set代表LR类
<img src=/images/posts/DB/33.JPG alt></p></li></ol><p>本章练习题：</p><ol><li>给定关系表r(R)和若干函数依赖，判断r是否满足函数依赖
运用SQL语句</li><li>判断关于函数依赖的一些公式是否成立：
Armstrong Axiom</li><li>求候选键</li><li>求属性闭包</li><li>求函数依赖集F的最小正则集</li><li>给定关系模式R和定义在R上的函数依赖集F，判断R属于第几范式</li><li>判断一个模式分解是否为无损连接、函数依赖保持</li><li>3NF、BCNF范式分解</li></ol></div><div class=btn-improve-page><a href=https://github.com/ztqakita/ztqakita.github.io/edit//content/posts/database-system/Database_System_2.md><i class="fas fa-code-branch"></i>Improve this page</a></div><hr><div class="row next-prev-navigator"><div class="col-md-6 previous-article"><a href=/posts/compiler/compilers_2/ class="btn btn-outline-info"><span><i class="fas fa-chevron-circle-left"></i>Prev</span><br><span>Syntax-directed Translation</span></a></div><div class="col-md-6 next-article"><a href=/posts/deep-learning/rnn/ class="btn btn-outline-info"><span>Next <i class="fas fa-chevron-circle-right"></i></span><br><span>Recursive Neural Network</span></a></div></div><hr></div></div></div><a id=scroll-to-top class=btn><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#72-concepts>7.2 Concepts</a></li><li><a href=#73-constraints>7.3 Constraints</a></li></ul><ul><li><a href=#82-atomic-domains-and-first-normal-form>8.2 Atomic Domains and First Normal Form</a></li><li><a href=#83-decomposition-using-functional-dependencies>8.3 Decomposition Using Functional Dependencies</a><ul><li><a href=#831-functional-dependencies>8.3.1 Functional Dependencies</a></li><li><a href=#832-boyce-codd-normal-form>8.3.2 Boyce-Codd Normal Form</a></li><li><a href=#834-third-normal-form>8.3.4 Third Normal Form</a></li></ul></li><li><a href=#84-functional-dependency-theory>8.4 Functional-Dependency Theory</a><ul><li><a href=#841-closure-of-a-set-of-fd>8.4.1 Closure of a Set of FD</a></li><li><a href=#842-closure-of-attribute-sets>8.4.2 Closure of Attribute Sets</a></li><li><a href=#843-canonical-cover>8.4.3 Canonical Cover</a></li><li><a href=#844-lossless-join-decomposition>8.4.4 Lossless-join Decomposition</a></li><li><a href=#845-dependency-preserving>8.4.5 Dependency Preserving</a></li><li><a href=#总结范式之间的关系>总结：范式之间的关系</a></li></ul></li><li><a href=#85-algorithms-for-decomposition>8.5 Algorithms for Decomposition</a><ul><li><a href=#851-bcnf-decomposition>8.5.1 BCNF Decomposition</a></li><li><a href=#852-3nf-decomposition>8.5.2 3NF Decomposition</a></li><li><a href=#853-computing-of-candidate-keys>8.5.3 Computing of Candidate Keys</a></li></ul></li></ul></nav></div></div></section></div><footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=#about>About</a></li><li class=nav-item><a class=smooth-scroll href=#skills>Skills</a></li><li class=nav-item><a class=smooth-scroll href=#experiences>Experiences</a></li><li class=nav-item><a class=smooth-scroll href=#projects>Projects</a></li><li class=nav-item><a class=smooth-scroll href=#recent-posts>Recent Posts</a></li><li class=nav-item><a class=smooth-scroll href=#achievements>Achievements</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><span>Email:</span> <span>ztqakita@163.com</span></li><li><span>Phone:</span> <span>(+86)18618180071</span></li></ul></div><div class="col-md-4 col-sm-12"><p>Stay up to date with email notification</p><form><div class=form-group><input type=email class=form-control id=exampleInputEmail1 aria-describedby=emailHelp placeholder="Enter email">
<small id=emailHelp class="form-text text-muted">We'll never share your email with anyone else.</small></div><button type=submit class="btn btn-info">Submit</button></form></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hossainemruz/toha target=#><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_2.png>
Toha</a></div><div class="col-md-4 text-center">© 2021 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/js/jquery-3.4.1.min.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/navbar.js></script><script src=/js/main.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js></script><script src=/js/single.js></script><script>hljs.initHighlightingOnLoad()</script><script type=text/javascript async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:!0,processEnvironments:!0,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var b=MathJax.Hub.getAllJax(),a;for(a=0;a<b.length;a+=1)b[a].SourceElement().parentNode.className+=' has-jax'}),MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></body></html>