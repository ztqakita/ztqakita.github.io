<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ztqakita's Blog</title><link>https://ztqakita.github.io/</link><description>Recent content on ztqakita's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 11 Jun 2021 06:00:20 +0600</lastBuildDate><atom:link href="https://ztqakita.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Resultados de Búsqueda</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.
No se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html
Establecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.
Esta implementación utiliza Fusejs, jquery y mark.js
Configuración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.</description></item><item><title>Resultados de Búsqueda</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.
No se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html
Establecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.
Esta implementación utiliza Fusejs, jquery y mark.js
Configuración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>অনুসন্ধানের ফলাফল</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>অনুসন্ধানের ফলাফল</title><link>https://ztqakita.github.io/search/</link><pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item><item><title>Self-attention</title><link>https://ztqakita.github.io/posts/deep-learning/self-attention/</link><pubDate>Fri, 11 Jun 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/deep-learning/self-attention/</guid><description>I. Self-attention Overview Input: A sequence of vectors (size not fixed) Output: Each vector has a label (POS tagging) The whole sequence has a label (sentiment analysis) Model decides the number of labels itself (seq2seq) Self-attention can handle global iformation, and FC can handle local information. Self-attention is the key module of Transformer, which will be shared in other articles.
II. How to work? Firstly, we should figure out the relevance between each vector.</description></item><item><title>Transformer</title><link>https://ztqakita.github.io/posts/deep-learning/trasnformer/</link><pubDate>Fri, 11 Jun 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/deep-learning/trasnformer/</guid><description>I. Transformer Overview Seq2seq model
Input: sequence of vector
Output: sequence (not fixed size)
II. Encoder It is actually a Self-Attention Model!
对于一个block，它的结构可以理解为以下的形式：
与self-attention不同的是，会采用residual add的方式，将self-attention得到的中间结果$a$加上输出$b$ 经过layer normalization得到新的输出 将新的output输入到FC中，并加上residual 再次经过layer normalization得到这一个block的结果。 理解了一个block以后，整个Encoder就是由n个这种block组成的network。
首先将word进行self-attention得到word embeddding，并在其中加入positional encoding信息 经过multi-head Attention或者Feed Forward Network后，都要接上residual + layer normalization，而这种设计结构就是Transformer Encoder的创新点所在。 III. Decoder —— Autoregressive(AT) The model structure of Decoder is shown as follow:
根据上图我们将逐步逐层地解释结构：
Masked Multi-head Self-attention 在产生每一个$b^i$ vector时，不能再看后面的信息，只能和前面的输入进行关系： 从细节上来看，要想得出$b^2$，我们只需将其和$k^1, k^2$做dot-product。</description></item><item><title>KNN</title><link>https://ztqakita.github.io/posts/machine-learning/knn/</link><pubDate>Wed, 21 Apr 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/machine-learning/knn/</guid><description>原理 K近邻算法简单、直观，大致步骤为：
输入：训练集 $$T = {(x_1,y_1), (x_2, y_2), \dots, (x_N, y_N)}$$ 输出： 根据给定的距离度量，在训练集T中找出与$x$最近邻的$k$个点，涵盖这$k$个点的邻域记作$N_K(x)$； 找出最近邻的$k$个点的一个方法是搜索$kd$树； 在$N_k(x)$中根据分类决策规则（多数表决）决定$x$的类别$y$: $$y = arg \max_{c_j} \sum_{x_i \in N_k(x)}I(y_i=c_j)$$ kd树</description></item><item><title>Ionic Currents</title><link>https://ztqakita.github.io/posts/neural-computation/1-ionic_currents/</link><pubDate>Fri, 16 Apr 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/neural-computation/1-ionic_currents/</guid><description>I. A mathematical model of a neuron Equivalent circuit model
Parts of the circuit:
Power supplies: multiple to power different parts of the circuit to do different things Integartor(积分器) of past inputs Temporal filter to smooth inputs in time Spike generator: the sodium current(钠通路) and potassium current(钾通路) make a spike generator that generates an action potential and then talks to another neurons. Oscillator(振荡器) The wires of brain: The intracellular and extracelluar sapce is filled with salt solution.</description></item><item><title>Support Vector Machines</title><link>https://ztqakita.github.io/posts/machine-learning/support-vector/</link><pubDate>Mon, 29 Mar 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/machine-learning/support-vector/</guid><description>支持向量机模型 学习策略：间隔最大化，可形式化为一个求解凸二次规划(convex quadratic programming)的最优化问题 一、线性可分支持向量机与硬间隔最大化 支持向量机的学习是在特征空间上进行的，需要从输入空间转换到特征空间上。
线性可分支持向量机：给定线性可分的训练集，通过间隔最大化或等价地求解相应的凸二次规划问题得到的分离超平面为： $$\omega^* x + b^* = 0$$ 以及相应的分类决策函数： $$f(x) = sign(\omega^* x + b^*)$$
函数间隔和几何间隔
函数间隔：对于给定的训练数据集$T$和超平面$(\omega, b)$，则 $$\hat{\gamma_i}=y_i(\omega \cdot x_i+b)$$
超平面关于数据集$T$的函数间隔为 $$\hat{\gamma}=\min_{i=1,\dots,N}\hat{\gamma_i}$$ 几何间隔：对于给定的训练数据集$T$和超平面$(\omega, b)$，则 $$\hat{\gamma_i}=y_i(\frac{\omega}{||\omega||} \cdot x_i+\frac{b}{||\omega||})$$
其中$||\omega||$是L2范数。 间隔最大化
输入：线性可分数据集$T$ 输出：最大间隔分离超平面和分类决策函数 构造并求解约束最优化问题： $$\min_{\omega,b} \quad \frac{1}{2}||\omega||^2 $$ $$ s.t. \qquad y_i(\omega \cdot x_i+b)-1 \geq 0, \quad i=1, 2, \dots, N$$ 求解得到最优解$\omega^* , b^*$。 支持向量</description></item><item><title>Decision Tree</title><link>https://ztqakita.github.io/posts/machine-learning/decision-tree/</link><pubDate>Mon, 22 Mar 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/machine-learning/decision-tree/</guid><description>原理 决策树模型与学习 决策树的内部节点表示一个特征或属性，叶节点表示一个类。
if-then规则：互斥且完备 本质： 从训练数据集中归纳出一组分类规则（估计出条件概率模型） 损失函数：正则化的极大似然函数 学习算法：启发式方法，得到(sub-optimal)的决策树 一、特征选择 准则：信息增益
熵： 设$X$是一个取有限个值的离散随机变量，定义为： $$H(X) = -\sum_{i=1}^n p_i\log p_i$$
条件熵： 随机变量$X$给定的条件下随机变量$Y$的条件熵$H(Y|X)$，定义为： $$H(Y|X) = \sum_{i=1}^np_iH(Y|X=x_i)$$ 当熵和条件熵中的概率由极大似然估计得到时，分别成为经验熵和经验条件熵
信息增益：表示得知特征$X$的信息使得类$Y$的信息不确定性减少的程度。这种差值也称为互信息 $$g(D,A)=H(D)-H(D|A)$$
特征选择方法：对训练数据集D，计算每一个特征的信息增益，选取信息增益最大的特征。
信息增益比 上述的特征选择存在偏向选择取值较多的特征的问题，使用information gain ratio可以解决这个问题。 定义为： $$g_R(D, A) = \frac{g(D,A)}{H_A(D)}$$ 其中，$H_A(D)=-\sum_{i=1}^n\frac{|D_i|}{D}\log_2\frac{|D_i|}{D} $，n是特征A的取值个数。 二、决策树的生成 ID3算法 C4.5算法的基础般，只用信息增益来选取特征。 C4.5算法 三、决策树的剪枝 决策树的生成很容易出现过拟合现象，所以需要利用剪枝(pruning)来简化决策树。 决策树的剪枝往往通过极小化决策树整体的损失函数(loss function)来实现： $$C_{\alpha}(T)=\sum_{i=1}^{|T|}N_tH_t(T) + \alpha|T|=C(T)+\alpha|T|$$ 其中$|T|$表示树T的叶结点个数，t是树T的叶结点，该叶结点上有$N_t$个样本点，$\alpha \geq 0$为参数。
通过式子可以看出$C(T)$代表了模型对训练数据的预测误差，即拟合程度；而$\alpha|T|$代表了模型的复杂度，可以理解为正则化的方式来增强模型的泛化能力。
而树的剪枝算法分为：
预剪枝：不足是基于贪心策略，带来欠拟合的风险 后剪枝 后剪枝与动态规划类似，生成一棵完整的决策树以后，自底向上地对非叶节点进行考察，若剪完后损失函数变小，则进行剪枝。</description></item><item><title>Basic Concepts</title><link>https://ztqakita.github.io/posts/machine-learning/basic-concepts/</link><pubDate>Wed, 27 Jan 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/machine-learning/basic-concepts/</guid><description>统计学习概念辨析 一、基本分类 1. 监督学习 监督学习的本质是学习输入到输出的映射的统计规律。需要注意的有以下要点：
输入空间与特征空间不一定为相同的空间，有时会将实例从输入空间映射到特征空间 训练数据由输入(特征向量)与输出对组成 任务问题分类： 回归问题：输入变量与输出变量均为连续变量的预测问题 分类问题：输出变量为有限个离散变量的预测问题 标注问题：输入变量与输出变量均为变量序列的预测问题 $X$和$Y$具有联合概率分布就是监督学习关于数据的基本假设，即假设训练数据和测试数据是依联合概率分布$P(X,Y)$独立同分布产生的 假设空间的确定意味着学习范围的确定 2. 无监督学习 无监督学习的本质是学习数据中的统计规律或潜在结构，需要注意的有以下要点：
可以用于对已有数据的分析，也可以用于对未来数据的预测 要学习的模型可以表示为$z=g(x)$，条件概率分布$P(z|x)$，或者条件概率分布$P(x|z)$的形式 3. 强化学习 强化学习的本质是学习最优的序贯决策。在学习过程中，系统不断地试错，以达到学习最优策略的目的。
强化学习的马尔可夫决策过程是状态、奖励、动作序列上的随机过程，由五元组$&amp;lt;S,A,P,r,\gamma&amp;gt;$组成：
$S$是state集合 $A$是action集合 $P$是状态转移概率(transition probability)函数： $$P(s'|s,a)=P(s_{t+1}=s'|s_t=s,a_t=a)$$ $r$是奖励函数(reward function): $$r(s,a)=E(r_{t+1}|s_t=s, a_t=a)$$ $\gamma$是衰减系数(discount factor): $$\gamma \in [0,1]$$ 马尔可夫决策过程具有马尔科夫性，下一个状态只依赖于前一个状态与动作，由状态转移概率函数$P(s'|s,a)$表示。下一个奖励依赖于前一个状态与动作，由奖励函数$r(s,a)$表示。
策略$\pi$：给定状态下动作的函数$a=f(s)$或者条件概率分布$P(a|s)$ 价值函数/状态价值函数：策略$\pi$从某一个状态$s$开始的长期累积奖励的数学期望： $$v_{\pi}(s)=E_{\pi}[r_{t+1}+\gamma r_{t+2}+\gamma^2r_{t+3}+\dots|s_t=s]$$ 动作价值函数：策略$\pi$从某一个状态$s$和动作$a$开始的长期累积奖励的数学期望： $$q_{\pi}(s,a)=E_{\pi}[r_{t+1}+\gamma r_{t+2}+\gamma^2r_{t+3}+\dots|s_t=s, a_t=a]$$ 强化学习的目标就是在所有可能的策略中选出价值函数最大的策略$\pi^*$。
强化学习的分类：
policy-based 不直接学习模型，试图求解最优策略$\pi^*$。学习通常从一个具体策略开始，通过搜索更优的策略进行。 value-based 试图求解最有价值函数($q^*(s,a)$)。学习通常从一个具体价值函数开始，通过搜索更优的价值函数进行。 model-based 直接学习马尔科夫决策过程的模型，通过模型对环境的反馈进行预测。 4.</description></item><item><title>Perceptron</title><link>https://ztqakita.github.io/posts/machine-learning/perceptron/</link><pubDate>Wed, 27 Jan 2021 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/machine-learning/perceptron/</guid><description>原理 参考：统计学习方法|感知机原理剖析及实现
输入：实例的特征向量 输出：实例的类别（二分类） 模型类别：判别模型 学习策略：基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型</description></item><item><title>Database System Lecture Note 4</title><link>https://ztqakita.github.io/posts/database-system/database_system_4/</link><pubDate>Mon, 14 Dec 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/database-system/database_system_4/</guid><description>Chapter 12 Query Processing 12.1 Overview 12.2 Measures of Query Cost Disk access is the predominant cost. Use the number of block transfered from disk and the number of seeks as the cost measures.
12.3 Selection Operation Types of query conditions (查询条件类型) equality(等值), e.g.salary = 100 range (范围), e.g. salary between 50 and 400 comparison (比较), e.g. salary &amp;gt;300 NOTE: B+索引可以使用全部查询类型，而Hash索引只能等值查询。
Several file scan algorithms linear search/scan – A1 无索引、乱序：扫描全部blocks，才能找到全部满足查询条件的数据。 Cost estimate = $b_r$ block transfers + 1 seek selections using indices – A2, A3, A4 A2 主索引：Cost = $(h_i + 1) \times (t_T + t_S)$ A3 聚集索引不唯一：Cost = $h_i \times (t_T + t_S) + t_S + t_T\times b$ A4 非聚集索引不唯一：Cost = $(h_i + n) \times (t_T + t_S)$ selections involving comparisons – A5, A6 A5: 主索引，找叶子节点 A6: 辅索引，找叶子节点所指向的记录 complex selections – A7, A8, A9, A10 12.</description></item><item><title>File System</title><link>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_6/</link><pubDate>Thu, 10 Dec 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_6/</guid><description>Chapter 10 File System Chapter 11 File System Inplementation</description></item><item><title>Mass-Storage Structure &amp; I/O System</title><link>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_7/</link><pubDate>Thu, 10 Dec 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_7/</guid><description>Chapter 12 Mass-Storage Structure hard disk drives(HDDs) and nonvolatile memory (NVM)
12.1-12.2 Disk Structure Mapping between disk and blocks 并行快速读取多个连续的blocks/sectors
Transfer rate: the rate at which data flow between the driver and the computer
The position time:
seek time: the time for the disk to move the disk arm to the cylinder containing the desired sector.平均为移动1/2*(总磁道数)所需的时间 rotational latency: the time for the desired sector to rotate to the disk head.</description></item><item><title>Database System Lecture Note 3</title><link>https://ztqakita.github.io/posts/database-system/database_system_3/</link><pubDate>Mon, 23 Nov 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/database-system/database_system_3/</guid><description>Chapter 10 Storage and File Structure 对于应用程序和disk而言，中间会有data buffer作为数据交换的缓冲池，替换算法一般采用LRU算法，注意两种可控的参数，在实验中会用到：
连接时长 buffer大小 逻辑结构：
流式文件、基于记录文件、基于索引文件 物理结构：
以block为单位进行存储 contiguous linked indexed 10.5 File Organization Each file is a sequence of records, and a relational table is a set of tuples. A tuple is stored as a record in the DB file.
10.5.1 Fixed-Length Records a block contains several records. Store record i starting from byte n * (i – 1), where n is the size of each record.</description></item><item><title>Greedy &amp; Back-track &amp; Branch and Bound</title><link>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-3/</link><pubDate>Mon, 16 Nov 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-3/</guid><description>贪心算法 算法+证明
一、最优装载问题 算法： void Loading(int x[], int w[], int c, int n) { int *t = new int [n+1]; Sort(w, t, n); for(int i = 0; i &amp;lt; n; i++) x[i] = 0; for(int i = 0; i &amp;lt; n &amp;amp;&amp;amp; w[t[i]] &amp;lt; c; i++) { x[t[i]] = 1; c -= w[t[i]]; } } 证明： 最优子结构性质： 二、哈夫曼编码 三、最小生成树 回溯法 子集树：0-1背包问题，从包含n个全集当中去选择一个子集，所有可能解是$O(2^n)$ 排序树：TSP问题，解是一个排列，所有可能解的规模是$O(n!)$
子集树：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间称为子集树。 遍历子集树 时间复杂度：$O(2^n)$ void backtrack (int t) { if (t&amp;gt;n) output(x); else { for (int i=0;i&amp;lt;=1;i++) { x[t]=i; if (legal(t)) backtrack(t+1); } } } 排列树：当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树成为排列树。 遍历排序树 时间复杂度：$O(n!</description></item><item><title>Memory Management</title><link>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_5/</link><pubDate>Fri, 13 Nov 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_5/</guid><description>Chapter 8 Memeory Management 8.1 Background Address Space: the memory scope that the process can access(可访问的(内)存储区范围)
A pair of base register and limit register define the logical address space 8.1.2 Address Binding Chapter 9 Virtual Memory</description></item><item><title>Semantic Analysis &amp; Runtime Environment</title><link>https://ztqakita.github.io/posts/compiler/compilers_3/</link><pubDate>Tue, 27 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/compiler/compilers_3/</guid><description>语法分析 知识点：
运行环境 知识点：
活动记录、控制栈 栈式存储分配 非局部名字的访问 参数传递方式 7.1 程序运行时的存储组织 7.1.1 程序运行空间的划分 活动与过程的概念 过程：静态概念 活动：一次过程的每次执行，是动态概念 两者可以为1:1或1:m的关系，递归过程中可能一若干个活动活着。
活动的生存期 活动的生存期要么是不重叠的，要么是嵌套的(区别于进程的地方！活动不可以并发执行！)
对于一个程序，它会向操作系统申请一块内存空间： 活动记录会在控制栈中根据栈式存储分配策略来实现。 7.1.2 活动记录与控制栈 控制栈 局部数据的安排 编址限制的影响(padding) 7.1.3 名字的作用域及名字绑定 名字的作用域： 最近嵌套原则
名字绑定： note: 对于递归程序中定义的名字，即使是同一个名字也可能映射到不同的存储空间。
左值：存储空间的地址 右值：存储空间的内容 7.2 存储分配策略 7.2.1 静态存储分配 条件：源程序中声明的各种数据对象所需存储空间的大小在编译时都可以确定。 存储分配：编译时,为他们分配固定的存储空间。 地址绑定：程序装入内存时进行。 运行期间：名字的左值保持不变 不允许递归调用和建立动态数据结构
7.2.2 栈式存储分配(重点) 递归调用：同一个过程在不同存储位置出现。
调用序列 返回序列 其中top_sp = top_ep' - C1 - C2; P是通过top_sp找到返回值并放入局部数据域中。</description></item><item><title>Syntax-directed Translation</title><link>https://ztqakita.github.io/posts/compiler/compilers_2/</link><pubDate>Tue, 27 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/compiler/compilers_2/</guid><description>语法制导翻译技术 整体思路：
首先，根据翻译目标来确定每个产生式的语义； 其次，根据产生式的含义，分析每个符号的语义； 再次，把这些语义以属性的形式附加到相应的文法符号上（即把语义和语言结构联系起来）； 然后，根据产生式的语义给出符号属性的求值规则 （即语义规则），从而形成语法制导定义。 ==翻译目标决定产生式的含义、决定文法符号应该具有的属性，也决定了产生式的语义规则。==
两种描述语法制导翻译的形式：
语法制导定义：是对翻译的高层次说明，它隐蔽了一些实现细节，无须指明翻译时语义规则的计算次序 L-属性可以一遍扫描，省去分析树和依赖图的步骤。 翻译方案：指明了语义规则的计算次序，规定了语义动作的执行时机。 5.1 语法制导定义以及翻译方案 5.1.1 语法制导定义 对上下文无关文法的推广
综合属性 左部符号的综合属性是从该产生式右部文法符号的属性值计算出来的；在分析树中，一个内部结点的综合属性是从其子结点的属性值计算出来的。 在分析树中，若一个结点的某一属性由其子节点属性决定，则为综合属性 若在一个语法制导定义仅仅使用综合属性，则称之为S-属性定义。而对于这种属性，通常采用自底向上的方法进行注释。 继承属性 出现在产生式右部的某文法符号的继承属性是从其所在产生式的左部非终结符号和/或右部文法符号的属性值计算出来的；在分析树中，一个结点的继承属性是从其兄弟结点和/或父结点的属性值计算出来的。 在分析树中，一个结点的继承属性由其父节点属性或它的兄弟节点属性值决定。 可以用继承属性表示程序设计语言中的上下文之间的依赖关系。 当一个语义规则的唯一目的是产生某个副作用，则通常写成过程调用或程序段，看成是产生式左部非终结符的虚拟综合属性
5.1.2 依赖图 在依赖图中：
为每个属性设置一个结点 如果属性b依赖于c，那么从属性c的结点有一条有向边连 到属性b的结点。 5.1.3 拓扑排序 首先找到入度为0的节点，删除该点及其边，重复该过程至所有点均被删除。
5.1.4 计算顺序 根据拓扑排序的顺序进行求值得到翻译。
总结：最基本的文法用于建立输入符号串的分析树；
为分析树构造依赖图； 对依赖图进行拓扑排序； 从这个序列得到语义规则的计算顺序； 照此计算顺序进行求值，得到对输入符号串的翻译。 5.1.5 S-属性与L-属性 S属性定义：仅仅涉及综合属性，是L属性的子集 L属性定义：要么是综合属性，要么是由父节点和左兄弟节点决定的继承属性。(右边的不行) 对于L属性计算顺序：深度优先遍历分析树 进入节点前，计算它的继承属性 从节点返回时，计算它的综合属性 5.</description></item><item><title>Database System Lecture Note 2</title><link>https://ztqakita.github.io/posts/database-system/database_system_2/</link><pubDate>Fri, 23 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/database-system/database_system_2/</guid><description>Chapter 7 Database Design and E-R Model 7.2 Concepts Entity sets Relationship sets 对于多元联系$\Rightarrow$二元联系$\Rightarrow$关系表 Attribute 7.3 Constraints Mapping Cardinalities one to one one to many many to one many to many Keys superkey candidate key primary key Chapter 8 Schema Normalization 核心思想：将large schemas decompose to smaller schema. 建立functional dependency, 并利用两表查询的的方式进行查询(此处详见第7章)。 在第7章通过将E-R图进行转换，得到面向特定的初始关系模式集，这些关系模式集可能存在多种数据依赖关系：
Functional Dependencies Multivalued Dependencies Join Dependencies (略) 如果直接根据初始关系模式构造DBS，由于初始关系模式中数据依赖关系的存在，可能会违反DB的完整性约束</description></item><item><title>Recursive Neural Network</title><link>https://ztqakita.github.io/posts/deep-learning/rnn/</link><pubDate>Thu, 15 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/deep-learning/rnn/</guid><description>I. RNN Structure Overview The input is a sequence of vectors. note: Changing the input sequence order will change the output
We use the same neural network to train, each color in NN means the same weight. When the values stored in the memory is different, the output will also be different. II. Types of RNN Elman&amp;rsquo;s memory restore the values of hidden layer output, and Jordan&amp;rsquo;s memory restore the values of output.</description></item><item><title>Process Synchronization</title><link>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_4/</link><pubDate>Wed, 14 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_4/</guid><description>Chapter 6 Process Synchronization 6.1 Background 6.1.1 Shared resources Def:
the resources (e.g., data, CPU, I/O ports, memory) that can be accessed by several cooperating processes concurrently the shared resources cannot be used by several processes simultaneously (or in parallel), only be used mutual exclusively(互斥) 信号量的三种用法：
资源互斥使用：资源只有1个实例，各个进程通过二元信号量mutex互斥地进入临界区，使用资源。 Mutex：代表资源的控制权，初值为1。 mutex = 1：buffer空闲 mutex = 0：buffer阻塞 资源竞争使用： 资源有多个实例，允许多个进程竞争使用资源。 多元信号量表示：(1)资源可用数目，(2)资源使用权 e.g. empty, full 进程间同步： 进程间的执行步骤需要有先后顺序关系 同步二元信号sync，初值为0 sync = 0：未开始跑 sync = 1：前面进程跑完 6.</description></item><item><title>CPU Scheduling</title><link>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_3/</link><pubDate>Mon, 12 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_3/</guid><description>Chapter 5 CPU Scheduling 5.1 Concepts on Scheduling 5.1.1 basic concepts CPU Scheduling: (短期调度) ==selecting + allocating + enabling, in kernel mode.== The procedure of selecting running entities in main memory ( i.e., processes or threads in the ready queue) according to some criteria, allocating CPU to the selected running entities, and then enabling them to run on CPU
CPU burst occurs: running state
I/O burst occurs: waiting state</description></item><item><title>Dynamic Programming</title><link>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-2/</link><pubDate>Mon, 05 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-2/</guid><description>Chapter 3 Dynamic Programming I. 基本思想 聪明的遍历方法 为全遍历，不同于贪心算法的单一路径 关键：==自底向上== 寻找最优子结构： ==该问题的最优解包含着其子问题的最优解== 验证方法：反证法 建立递推关系 II. 矩阵连乘问题 最优解 == 以最少的数乘次数计算出矩阵连乘的乘积
引子想法：改进分治法 原本的分治法： 通过递归树，可以发现在递归中经常会重复计算： 思路是将重复计算的部分存储进二维数组之中，这种方法是基于分治法的改进方法 int LookupChain(int i，int j) { if (m[i][j] &amp;gt; 0) return m[i][j]; if (i == j) return 0; int u = LookupChain(i，i) + LookupChain(i+1，j) + p[i-1]*p[i]*p[j]; s[i][j] = i; for (int k = i+1; k &amp;lt; j; k++) { int t = LookupChain(i，k) + LookupChain(k+1，j) + p[i-1]*p[k]*p[j]; if (t &amp;lt; u) { u = t; s[i][j] = k; } } m[i][j] = u; return u; } 动态规划法 动态规划先从最小的子问题开始计算，==自底向上==进行合并运算。这种方法不需要递归，而且也可以避免重复计算。 (1) 分析最优子结构 原问题的最优解可以由子问题的最优解解决，对于动态规划问题，首先需要证明该问题==满足最优子结构性质==(利用反证法) 矩阵连乘问题符合最优子结构的证明： 假设$A[i:j]=A[i:k]+A[k+1:j]$是最小的计算量，且有$A[i:m]+A[m+1:j] &amp;lt; A[i:k]+A[k+1:j]$，则可以发现原$A[i:j] &amp;lt; A[i:m]+A[m+1:j]$，此时不满足假设条件，矛盾！</description></item><item><title>Process &amp; Threads</title><link>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_2/</link><pubDate>Mon, 28 Sep 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_2/</guid><description>Chapter 3: Process 3.1 Process Concept 3.1.1 Process Definition A process is
a program in execution the unit of resources (CPU, memory, I/O devices) allocation runs concurrently with other processes Another definition: 具有一定独立功能的某个程序关于某个数据集合的一次运行活动。是系统进行资源分配和调度的独立单位。(又称task，job)
进程的特点：
动态性：可动态地创建、结束进程 并发性：进程可以被独立调度并占用处理机运行(并发&amp;amp;并行) 独立性：不同进程的工作不相互影响 制约性：因访问共享数据/资源或进程同步而产生制约(进程之间有交互、共享等情况) Process = program + data + PCB. 3.1.2 Process State A process is dynamic, and has its lifetime. As a process executes, it changes among the following states: new: the process is being created.</description></item><item><title>Lexcial Analysis &amp; Parsing</title><link>https://ztqakita.github.io/posts/compiler/compilers_1/</link><pubDate>Tue, 22 Sep 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/compiler/compilers_1/</guid><description>I. 词法分析 词法分析器作用：
扫描源程序字符流 按照源语言的词法规则识别出各类单词符号 产生用于语法分析的记号序列 词法检查 创建符号表 &amp;mdash; 为语法分析使用 接口：跳过注释、标注错误信息 一、词法分析程序与语法分析程序的关系 1.1 词法分析程序作为独立的一遍 1.2 词法分析程序作为语法分析程序的子程序 词法分析相当于函数，语法分析每一次需要记号时即调用词法分析函数获得记号。 这种操作的好处可以避免中间文件、省去取送记号的工作。
1.3 词法分析程序与语法分析程序作为协同程序 这种方法不常用。
二、词法分析程序的输入与输出 2.1 配对缓冲区 哨兵！！！(EOF)
把一个缓冲器分为大小相同的两半，每半各含N个字符，一般N=1KB或4KB。为了使得判断更为优化，在每个半区后面加上EOF。 这种做法是为了让缓冲区可以处理超出其范围的字符串。
2.2 词法分析程序的输出——记号 记号：某一类单词符号的类别编码，如id，num 模式：某一类单词符号的构成规则，如“有字母开头的字母字符串” 单词：某一类单词符号的具体实例，如hello 记号的属性 作用：记号影响语法分析的决策，属性影响记号的翻译。 三、记号的描述和识别 3.1 词法与正规文法 描述语言的标识符、常数、运算符和标点符号等记号的文法
3.2 记号的文法 标识符 描述标识符集合的正则表达式： 标识符的正规文法(右线性文法) 常数 整数 描述整数结构的正则表达式：
无符号数
运算符 分界符 关键字 四、词法分析程序的设计与实现 五、软件工具LEX II.</description></item><item><title>Complexity &amp; Divide and Conquer</title><link>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-1/</link><pubDate>Mon, 21 Sep 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-1/</guid><description>Chapter 1 I. 算法及算法复杂度 1. Definition Input Output Definiteness Finiteness Effectiveness note: program vs algorithm program: A program is written in some programming language, and does not have to be finite. algorithm: An algorithm can be described by human languages, flow charts, some programming languages, or pseudo-code.
2. 算法的评价 正确性 健壮性 复杂性 时间复杂度 空间复杂度 可读性 简单性 II. 算法复杂度分析 1. 指标 平均时间复杂度 最坏时间复杂度 2.</description></item><item><title>Introduction &amp; OS Structure</title><link>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_1/</link><pubDate>Mon, 21 Sep 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/operating-system/operating_system_concepts_1/</guid><description>Chapter 1: Introduction 1.1 OS Definition A program that acts as an intermediary between a user of a computer and the computer hardware.
Computer System Structure 1.1.1 User View ease of use Do not care about resource utilization! 1.1.2 System View resourse allocator control program 1.2 Computer-System Organization bootstrap program: Typically stored in ROM or EPROM, generally known as firmware. Initializes all aspects of system. Loads operating system kernel and starts execution.</description></item><item><title>Database System Lecture Note 1</title><link>https://ztqakita.github.io/posts/database-system/database_system_1/</link><pubDate>Tue, 15 Sep 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/database-system/database_system_1/</guid><description>Chapter 1 Introduction 1.1 DB, DBMS, DBS, DBAS DB: a collection of interrelated data stored in systems as files DBMS: a set of programs to access the data in DB DBS: users + DBMS + DB 1.2 View of Data 1.2.1 Levels of Data Abstraction View Level: how the data items in DB are used by different users Logical Level: e.</description></item><item><title>Convolutional Neural Network</title><link>https://ztqakita.github.io/posts/deep-learning/cnn/</link><pubDate>Mon, 14 Sep 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/deep-learning/cnn/</guid><description>I. CNN Structure Overview II. Convolution Note: 1.Every elements in filter are the network parameter to be learned. 2.Stride means each step you walk from previous position. 3.The size of filter is decided by programmer.
From the picture we could know the largest values of Feature Map means there has a feature. Then we do the same process for every filter and generate more Feature Map.
If we deal with colorful image, we will use Filter Cube instead of matrix.</description></item><item><title>Introduction to Deep Learning</title><link>https://ztqakita.github.io/posts/deep-learning/introduction-to-deep-learning/</link><pubDate>Mon, 10 Aug 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/deep-learning/introduction-to-deep-learning/</guid><description>I. Basic Concepts 1. Fully Connected Feedforward Network 2. Matrix Operation Every layer has weight matrix and bias matrix, using matrix operation we can accumulate the output matrix $y$. Tips: Using GPU could speed up matrix operation.
II. Why Deep Learning? 1. Modularization 对neural network而言，并不是神经元越多越好，通过例子可以看出层数的增加（more deep）对于准确率的提升更有效果。这其中就是 Modularization 的思想。For example, while you are trying to train the model below, you can use basic classifiers as module. Each basic classifier can have sufficient training examples.</description></item><item><title>Classification</title><link>https://ztqakita.github.io/posts/machine-learning/classification/</link><pubDate>Tue, 28 Jul 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/machine-learning/classification/</guid><description>Classification I. Probabilistic Generative Models 1. Detailed Process The basic idea is estimating the probabilities form training data. Let&amp;rsquo;s consider the two classes case: First of all, we need to figure out prior class probabilities $P(C_k)$. It&amp;rsquo;s pretty easy to find that $P(C_k) = \frac{SizeOf C_k}{SizeOf Training Data}$ Then the task is to find out $P(x|C_k)$. Each data is represented as a vector by its attribute, and it exist as a point in a multidimensional space.</description></item><item><title>Optimization for Deep Learning</title><link>https://ztqakita.github.io/posts/deep-learning/optimizer-for-dl/</link><pubDate>Sat, 25 Jul 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/deep-learning/optimizer-for-dl/</guid><description>Some Notation: $\theta_t$: model parameter at time step t $\nabla$$L(\theta_t)$ or $g_t$: gradient at $\theta_t$, used to compute $\theta_{t+1}$ $m_{t+1}$: momentum accumlated from time step 0 to time step t, which is used to compute $\theta_{t+1}$
I. Adaptive Learning Rates In gradient descent, we need to set the learning rate to converge properly and find the local minima. But sometimes it&amp;rsquo;s difficult to find a proper value of the learning rate.</description></item><item><title>Introduction</title><link>https://ztqakita.github.io/posts/introduction/</link><pubDate>Mon, 08 Jun 2020 08:06:25 +0600</pubDate><guid>https://ztqakita.github.io/posts/introduction/</guid><description>Greeting! This is an introduction post. This post tests the followings:
Hero image is in the same directory as the post. This post should be at top of the sidebar. Post author should be the same as specified in author.yaml file.</description></item><item><title>Search Results</title><link>https://ztqakita.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ztqakita.github.io/search/</guid><description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description></item></channel></rss>