<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on ztqakita's Blog</title><link>https://ztqakita.github.io/posts/algorithms/</link><description>Recent content in Algorithms on ztqakita's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 16 Nov 2020 06:00:20 +0600</lastBuildDate><atom:link href="https://ztqakita.github.io/posts/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Greedy &amp; Back-track &amp; Branch and Bound</title><link>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-3/</link><pubDate>Mon, 16 Nov 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-3/</guid><description>贪心算法 算法+证明
一、最优装载问题 算法： void Loading(int x[], int w[], int c, int n) { int *t = new int [n+1]; Sort(w, t, n); for(int i = 0; i &amp;lt; n; i++) x[i] = 0; for(int i = 0; i &amp;lt; n &amp;amp;&amp;amp; w[t[i]] &amp;lt; c; i++) { x[t[i]] = 1; c -= w[t[i]]; } } 证明： 最优子结构性质： 二、哈夫曼编码 三、最小生成树 回溯法 子集树：0-1背包问题，从包含n个全集当中去选择一个子集，所有可能解是$O(2^n)$ 排序树：TSP问题，解是一个排列，所有可能解的规模是$O(n!)$
子集树：当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间称为子集树。 遍历子集树 时间复杂度：$O(2^n)$ void backtrack (int t) { if (t&amp;gt;n) output(x); else { for (int i=0;i&amp;lt;=1;i++) { x[t]=i; if (legal(t)) backtrack(t+1); } } } 排列树：当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树成为排列树。 遍历排序树 时间复杂度：$O(n!</description></item><item><title>Dynamic Programming</title><link>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-2/</link><pubDate>Mon, 05 Oct 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-2/</guid><description>Chapter 3 Dynamic Programming I. 基本思想 聪明的遍历方法 为全遍历，不同于贪心算法的单一路径 关键：==自底向上== 寻找最优子结构： ==该问题的最优解包含着其子问题的最优解== 验证方法：反证法 建立递推关系 II. 矩阵连乘问题 最优解 == 以最少的数乘次数计算出矩阵连乘的乘积
引子想法：改进分治法 原本的分治法： 通过递归树，可以发现在递归中经常会重复计算： 思路是将重复计算的部分存储进二维数组之中，这种方法是基于分治法的改进方法 int LookupChain(int i，int j) { if (m[i][j] &amp;gt; 0) return m[i][j]; if (i == j) return 0; int u = LookupChain(i，i) + LookupChain(i+1，j) + p[i-1]*p[i]*p[j]; s[i][j] = i; for (int k = i+1; k &amp;lt; j; k++) { int t = LookupChain(i，k) + LookupChain(k+1，j) + p[i-1]*p[k]*p[j]; if (t &amp;lt; u) { u = t; s[i][j] = k; } } m[i][j] = u; return u; } 动态规划法 动态规划先从最小的子问题开始计算，==自底向上==进行合并运算。这种方法不需要递归，而且也可以避免重复计算。 (1) 分析最优子结构 原问题的最优解可以由子问题的最优解解决，对于动态规划问题，首先需要证明该问题==满足最优子结构性质==(利用反证法) 矩阵连乘问题符合最优子结构的证明： 假设$A[i:j]=A[i:k]+A[k+1:j]$是最小的计算量，且有$A[i:m]+A[m+1:j] &amp;lt; A[i:k]+A[k+1:j]$，则可以发现原$A[i:j] &amp;lt; A[i:m]+A[m+1:j]$，此时不满足假设条件，矛盾！</description></item><item><title>Complexity &amp; Divide and Conquer</title><link>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-1/</link><pubDate>Mon, 21 Sep 2020 06:00:20 +0600</pubDate><guid>https://ztqakita.github.io/posts/algorithms/algorithm_analysis-1/</guid><description>Chapter 1 I. 算法及算法复杂度 1. Definition Input Output Definiteness Finiteness Effectiveness note: program vs algorithm program: A program is written in some programming language, and does not have to be finite. algorithm: An algorithm can be described by human languages, flow charts, some programming languages, or pseudo-code.
2. 算法的评价 正确性 健壮性 复杂性 时间复杂度 空间复杂度 可读性 简单性 II. 算法复杂度分析 1. 指标 平均时间复杂度 最坏时间复杂度 2.</description></item></channel></rss>